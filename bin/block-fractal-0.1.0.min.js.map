{"version":3,"sources":["webpack:///block-fractal-0.1.0.min.js","webpack:///webpack/bootstrap cff34591ea85cb3ccb78","webpack:///./src/geom/index.ts","webpack:///./src/block-fractal.ts","webpack:///./src/geom/direction-flags.ts","webpack:///./src/geom/direction.ts","webpack:///./src/geom/mask-rect.ts","webpack:///./src/geom/mask.ts","webpack:///./src/geom/offset.ts","webpack:///./src/geom/path.ts","webpack:///./src/geom/raster-mask.ts","webpack:///./src/geom/rectangle.ts","webpack:///./src/geom/size.ts","webpack:///./src/index.ts"],"names":["BlockFractal","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__export","nextToLastMatch","points","next","length","equals","addPoint","mask","set","splice","push","verticalHelper","random","variation","newPoints","p1","p2","x","yDir","y","np3","geom","Offset","index","findIndex","point","_i","_a","v","Math","floor","np1","np2","horizontalHelper","xDir","blockFractalIteration","bounds","Array","newBounds","Rectangle","westX","northY","width","height","MaskRect","makeBlockFractal","param","shape","Path","Direction","EAST","SOUTH","WEST","NORTH","getBounds","getOffsets","off","iter","iterations","segments","curPoint","nextPoint","directionFlagsToString","flags","ret","DirectionFlags","directionFlagsFromDirection","dir","directionToString","DIRECTIONS_STR","directionOpposite","DIRECTIONS","LOCAL_OFF","rect","initialValue","outsideValue","this","_rectangle","copyFrom","_mask","Mask","_outsideValue","toString","northWest","subtractOffset","getAt","containsOffset","setAt","size","_size","Size","_bits","area","fill","X_FROM_DIRECTION","Y_FROM_DIRECTION","other","max","abs","setFromDirection","add","addSize","addOffset","addDirection","addCardinalDirection","multiply","factor","distanceChebyshev","magnitudeChebyshev","distanceManhattan","magnitudeManhattan","sortedInsert","array","low","high","mid","start","map","segment","join","getIsClosed","callback","cursor","southY","eastX","min","rasterize","lines","RasterMask","_lines","line","end","bandsAt","empty","extendToInclude","dx","dy","containsRectangle","overlapsRectangle","block_fractal_1","geom_1"],"mappings":"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","file":"block-fractal-0.1.0.min.js","sourcesContent":["var BlockFractal =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/bin/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 11);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(__webpack_require__(3));\r\n__export(__webpack_require__(2));\r\n__export(__webpack_require__(6));\r\n__export(__webpack_require__(10));\r\n__export(__webpack_require__(9));\r\n__export(__webpack_require__(5));\r\n__export(__webpack_require__(4));\r\n__export(__webpack_require__(8));\r\n__export(__webpack_require__(7));\r\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar geom = __webpack_require__(0);\r\nfunction nextToLastMatch(points, next) {\r\n    return points.length > 1 && points[points.length - 2].equals(next);\r\n}\r\nfunction addPoint(points, mask, next) {\r\n    if (nextToLastMatch(points, next)) {\r\n        mask.set(points.splice(points.length - 1, 1)[0], false);\r\n    }\r\n    else {\r\n        points.push(next);\r\n        mask.set(next, true);\r\n    }\r\n}\r\nfunction verticalHelper(points, random, variation, newPoints, mask, i, p1, p2) {\r\n    var x = 2 * p1.x;\r\n    var yDir = p2.y - p1.y;\r\n    var _loop_1 = function (y) {\r\n        var np3 = new geom.Offset(x, y + yDir);\r\n        // console.info(`- ${np3}`);\r\n        if (nextToLastMatch(newPoints, np3)) {\r\n            // This can happen around a corner, when just before the corner\r\n            // we dip into the corner\r\n            // console.info(` remove ${newPoints[newPoints.length - 1]}`);\r\n            mask.set(newPoints.splice(newPoints.length - 1, 1)[0], false);\r\n            return \"continue\";\r\n        }\r\n        if (i === points.length - 2 && mask.get(np3)) {\r\n            // This can happen if the first point was on a corner and the\r\n            // first move was to dip into the corner\r\n            var index = newPoints.findIndex(function (point) { return point.equals(np3); });\r\n            // console.info(`remove ${index} from beginning`);\r\n            for (var _i = 0, _a = newPoints.splice(0, index); _i < _a.length; _i++) {\r\n                var point = _a[_i];\r\n                mask.set(point, false);\r\n            }\r\n            addPoint(newPoints, mask, np3);\r\n            return \"break\";\r\n        }\r\n        if (random() < variation) {\r\n            var v = Math.floor(random() * 2) * 2 - 1;\r\n            var np1 = new geom.Offset(x + v, y);\r\n            var np2 = new geom.Offset(x + v, y + yDir);\r\n            if (!mask.get(np1) && !mask.get(np2)) {\r\n                addPoint(newPoints, mask, np1);\r\n                addPoint(newPoints, mask, np2);\r\n            }\r\n        }\r\n        addPoint(newPoints, mask, np3);\r\n    };\r\n    for (var y = 2 * p1.y; y !== 2 * p2.y; y += yDir) {\r\n        var state_1 = _loop_1(y);\r\n        if (state_1 === \"break\")\r\n            break;\r\n    }\r\n}\r\nfunction horizontalHelper(points, random, variation, newPoints, mask, i, p1, p2) {\r\n    var y = 2 * p1.y;\r\n    var xDir = p2.x - p1.x;\r\n    var _loop_2 = function (x) {\r\n        var np3 = new geom.Offset(x + xDir, y);\r\n        // console.info(`- ${np3}`);\r\n        if (nextToLastMatch(newPoints, np3)) {\r\n            // This can happen around a corner, when just before the corner\r\n            // we dip in the direction of the corner\r\n            // console.info(` remove ${newPoints[newPoints.length - 1]}`);\r\n            mask.set(newPoints.splice(newPoints.length - 1, 1)[0], false);\r\n            return \"continue\";\r\n        }\r\n        if (i === points.length - 2 && mask.get(np3)) {\r\n            // This can happen if the first point was on a corner and the\r\n            // first move was to dip into the corner\r\n            var index = newPoints.findIndex(function (point) { return point.equals(np3); });\r\n            // console.info(`remove ${index} from beginning`);\r\n            for (var _i = 0, _a = newPoints.splice(0, index); _i < _a.length; _i++) {\r\n                var point = _a[_i];\r\n                mask.set(point, false);\r\n            }\r\n            addPoint(newPoints, mask, np3);\r\n            return \"break\";\r\n        }\r\n        if (random() < variation) {\r\n            var v = Math.floor(random() * 2) * 2 - 1;\r\n            var np1 = new geom.Offset(x, y + v);\r\n            var np2 = new geom.Offset(x + xDir, y + v);\r\n            if (!mask.get(np1) && !mask.get(np2)) {\r\n                addPoint(newPoints, mask, np1);\r\n                addPoint(newPoints, mask, np2);\r\n            }\r\n        }\r\n        addPoint(newPoints, mask, np3);\r\n    };\r\n    for (var x = 2 * p1.x; x !== 2 * p2.x; x += xDir) {\r\n        var state_2 = _loop_2(x);\r\n        if (state_2 === \"break\")\r\n            break;\r\n    }\r\n}\r\nfunction blockFractalIteration(random, points, bounds, variation) {\r\n    var newPoints = new Array();\r\n    var newBounds = new geom.Rectangle(bounds.westX * 2 - 1, bounds.northY * 2 - 1, bounds.width * 2 + 2, bounds.height * 2 + 2);\r\n    // console.info(` bounds ${newBounds}`);\r\n    var mask = new geom.MaskRect(newBounds);\r\n    for (var i = 0; i < points.length - 1; i++) {\r\n        var p1 = points[i];\r\n        var p2 = points[i + 1];\r\n        if (i === 0) {\r\n            addPoint(newPoints, mask, new geom.Offset(p1.x * 2, p1.y * 2));\r\n        }\r\n        if (p1.x === p2.x) {\r\n            verticalHelper(points, random, variation, newPoints, mask, i, p1, p2);\r\n        }\r\n        else {\r\n            horizontalHelper(points, random, variation, newPoints, mask, i, p1, p2);\r\n        }\r\n    }\r\n    return {\r\n        points: newPoints,\r\n        bounds: newBounds,\r\n    };\r\n}\r\nfunction makeBlockFractal(param) {\r\n    var random = param.random, shape = param.shape, variation = param.variation;\r\n    if (typeof random === 'undefined') {\r\n        random = Math.random;\r\n    }\r\n    if (typeof shape === 'undefined') {\r\n        shape = new geom.Path({ x: -1, y: -1 }, [\r\n            geom.Direction.EAST,\r\n            geom.Direction.EAST,\r\n            geom.Direction.SOUTH,\r\n            geom.Direction.SOUTH,\r\n            geom.Direction.WEST,\r\n            geom.Direction.WEST,\r\n            geom.Direction.NORTH,\r\n            geom.Direction.NORTH,\r\n        ]);\r\n    }\r\n    if (typeof variation === 'undefined') {\r\n        variation = 0.4;\r\n    }\r\n    var points = new Array();\r\n    var bounds = shape.getBounds();\r\n    shape.getOffsets(function (off) {\r\n        points.push(new geom.Offset(off.x, off.y));\r\n    });\r\n    for (var iter = 0; iter < param.iterations; iter++) {\r\n        // console.info(`iteration ${iter + 1}`);\r\n        (_a = blockFractalIteration(random, points, bounds, variation), points = _a.points, bounds = _a.bounds);\r\n    }\r\n    var segments = new Array();\r\n    for (var i = 0; i < points.length - 1; i++) {\r\n        var curPoint = points[i];\r\n        var nextPoint = points[i + 1];\r\n        if (nextPoint.y === curPoint.y - 1) {\r\n            segments.push(geom.Direction.NORTH);\r\n        }\r\n        else if (nextPoint.x === curPoint.x + 1) {\r\n            segments.push(geom.Direction.EAST);\r\n        }\r\n        else if (nextPoint.y === curPoint.y + 1) {\r\n            segments.push(geom.Direction.SOUTH);\r\n        }\r\n        else if (nextPoint.x === curPoint.x - 1) {\r\n            segments.push(geom.Direction.WEST);\r\n        }\r\n    }\r\n    return new geom.Path(points[0], segments);\r\n    var _a;\r\n}\r\nexports.makeBlockFractal = makeBlockFractal;\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// tslint:disable:no-bitwise\r\nvar DirectionFlags;\r\n(function (DirectionFlags) {\r\n    DirectionFlags[DirectionFlags[\"NONE\"] = 0] = \"NONE\";\r\n    DirectionFlags[DirectionFlags[\"NORTH\"] = 1] = \"NORTH\";\r\n    DirectionFlags[DirectionFlags[\"EAST\"] = 2] = \"EAST\";\r\n    DirectionFlags[DirectionFlags[\"SOUTH\"] = 4] = \"SOUTH\";\r\n    DirectionFlags[DirectionFlags[\"WEST\"] = 8] = \"WEST\";\r\n    DirectionFlags[DirectionFlags[\"ALL\"] = 15] = \"ALL\";\r\n})(DirectionFlags = exports.DirectionFlags || (exports.DirectionFlags = {}));\r\nfunction directionFlagsToString(flags) {\r\n    var ret = '[';\r\n    if ((flags & DirectionFlags.NORTH) !== 0) {\r\n        ret += 'N';\r\n    }\r\n    if ((flags & DirectionFlags.EAST) !== 0) {\r\n        ret += 'E';\r\n    }\r\n    if ((flags & DirectionFlags.SOUTH) !== 0) {\r\n        ret += 'S';\r\n    }\r\n    if ((flags & DirectionFlags.WEST) !== 0) {\r\n        ret += 'W';\r\n    }\r\n    return ret + ']';\r\n}\r\nexports.directionFlagsToString = directionFlagsToString;\r\n// conversion\r\nfunction directionFlagsFromDirection(dir) {\r\n    return (1 << dir);\r\n}\r\nexports.directionFlagsFromDirection = directionFlagsFromDirection;\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\n// tslint:disable:no-bitwise\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Direction;\r\n(function (Direction) {\r\n    Direction[Direction[\"NORTH\"] = 0] = \"NORTH\";\r\n    Direction[Direction[\"EAST\"] = 1] = \"EAST\";\r\n    Direction[Direction[\"SOUTH\"] = 2] = \"SOUTH\";\r\n    Direction[Direction[\"WEST\"] = 3] = \"WEST\";\r\n})(Direction = exports.Direction || (exports.Direction = {}));\r\nexports.DIRECTIONS = [\r\n    Direction.NORTH,\r\n    Direction.EAST,\r\n    Direction.SOUTH,\r\n    Direction.WEST,\r\n];\r\nvar DIRECTIONS_STR = [\r\n    'N',\r\n    'E',\r\n    'S',\r\n    'W',\r\n];\r\nfunction directionToString(dir) {\r\n    return DIRECTIONS_STR[dir];\r\n}\r\nexports.directionToString = directionToString;\r\nfunction directionOpposite(dir) {\r\n    return ((dir + 2) & 3);\r\n}\r\nexports.directionOpposite = directionOpposite;\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar geom = __webpack_require__(0);\r\nvar LOCAL_OFF = new geom.Offset();\r\nvar MaskRect = (function () {\r\n    function MaskRect(rect, initialValue, outsideValue) {\r\n        if (initialValue === void 0) { initialValue = false; }\r\n        if (outsideValue === void 0) { outsideValue = false; }\r\n        this._rectangle = new geom.Rectangle();\r\n        this._rectangle.copyFrom(rect);\r\n        this._mask = new geom.Mask(rect, initialValue);\r\n        this._outsideValue = outsideValue;\r\n    }\r\n    // accessors\r\n    MaskRect.prototype.toString = function () {\r\n        return this._rectangle.northWest + \"/\" + this._outsideValue + \"\\n\" + this._mask;\r\n    };\r\n    Object.defineProperty(MaskRect.prototype, \"westX\", {\r\n        get: function () {\r\n            return this._rectangle.westX;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaskRect.prototype, \"northY\", {\r\n        get: function () {\r\n            return this._rectangle.northY;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaskRect.prototype, \"width\", {\r\n        get: function () {\r\n            return this._rectangle.width;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaskRect.prototype, \"height\", {\r\n        get: function () {\r\n            return this._rectangle.height;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    MaskRect.prototype.index = function (off) {\r\n        return this._mask.index(LOCAL_OFF.copyFrom(off).subtractOffset(this._rectangle.northWest));\r\n    };\r\n    MaskRect.prototype.getAt = function (index) {\r\n        return this._mask.getAt(index);\r\n    };\r\n    MaskRect.prototype.get = function (off) {\r\n        if (!this._rectangle.containsOffset(off)) {\r\n            return this._outsideValue;\r\n        }\r\n        return this._mask.getAt(this._rectangle.index(off));\r\n    };\r\n    // mutators\r\n    MaskRect.prototype.setAt = function (index, value) {\r\n        this._mask.setAt(index, value);\r\n        return this;\r\n    };\r\n    MaskRect.prototype.set = function (off, value) {\r\n        this._mask.setAt(this._rectangle.index(off), value);\r\n        return this;\r\n    };\r\n    return MaskRect;\r\n}());\r\nexports.MaskRect = MaskRect;\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar geom = __webpack_require__(0);\r\nvar Mask = (function () {\r\n    // TODO consider Uint8Array for bits\r\n    function Mask(size, initialValue) {\r\n        if (initialValue === void 0) { initialValue = false; }\r\n        this._size = new geom.Size();\r\n        this._size.copyFrom(size);\r\n        this._bits = new Array(this._size.area).fill(initialValue);\r\n    }\r\n    // accessors\r\n    Mask.prototype.toString = function () {\r\n        var ret = '';\r\n        var off = new geom.Offset();\r\n        for (var y = 0; y < this._size.height; y++) {\r\n            for (var x = 0; x < this._size.width; x++) {\r\n                off.set(x, y);\r\n                ret += this.get(off.set(x, y)) ? '☑' : '☐';\r\n            }\r\n            ret += '\\n';\r\n        }\r\n        return ret;\r\n    };\r\n    Object.defineProperty(Mask.prototype, \"width\", {\r\n        get: function () {\r\n            return this._size.width;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mask.prototype, \"height\", {\r\n        get: function () {\r\n            return this._size.height;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Mask.prototype.index = function (off) {\r\n        return this._size.index(off);\r\n    };\r\n    Mask.prototype.getAt = function (index) {\r\n        return this._bits[index];\r\n    };\r\n    Mask.prototype.get = function (off) {\r\n        return this.getAt(this.index(off));\r\n    };\r\n    // mutators\r\n    Mask.prototype.setAt = function (index, value) {\r\n        this._bits[index] = value;\r\n        return this;\r\n    };\r\n    Mask.prototype.set = function (off, value) {\r\n        return this.setAt(this.index(off), value);\r\n    };\r\n    return Mask;\r\n}());\r\nexports.Mask = Mask;\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar X_FROM_DIRECTION = [0, 1, 0, -1];\r\nvar Y_FROM_DIRECTION = [-1, 0, 1, 0];\r\nvar Offset = (function () {\r\n    function Offset(x, y) {\r\n        if (typeof x === 'undefined') {\r\n            x = 0;\r\n        }\r\n        if (typeof y === 'undefined') {\r\n            y = 0;\r\n        }\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    // accessors\r\n    Offset.prototype.toString = function () {\r\n        return \"(\" + this.x + \",\" + this.y + \")\";\r\n    };\r\n    Offset.prototype.equals = function (other) {\r\n        return this.x === other.x && this.y === other.y;\r\n    };\r\n    Object.defineProperty(Offset.prototype, \"magnitudeChebyshev\", {\r\n        // chebyshev: can move in any direction (diagonals are ok)\r\n        get: function () {\r\n            return Math.max(Math.abs(this.x), Math.abs(this.y));\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Offset.prototype, \"magnitudeManhattan\", {\r\n        // manhattan: can move only in cardinal directions (no diagonals)\r\n        get: function () {\r\n            return Math.abs(this.x) + Math.abs(this.y);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    // mutators\r\n    Offset.prototype.set = function (x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    };\r\n    Offset.prototype.copyFrom = function (other) {\r\n        this.x = other.x;\r\n        this.y = other.y;\r\n        return this;\r\n    };\r\n    Offset.prototype.setFromDirection = function (dir) {\r\n        this.x = X_FROM_DIRECTION[dir];\r\n        this.y = Y_FROM_DIRECTION[dir];\r\n        return this;\r\n    };\r\n    Offset.prototype.add = function (x, y) {\r\n        this.x += x;\r\n        this.y += y;\r\n        return this;\r\n    };\r\n    Offset.prototype.addSize = function (size) {\r\n        this.x += size.width;\r\n        this.y += size.height;\r\n        return this;\r\n    };\r\n    Offset.prototype.addOffset = function (off) {\r\n        this.x += off.x;\r\n        this.y += off.y;\r\n        return this;\r\n    };\r\n    Offset.prototype.addDirection = function (dir) {\r\n        this.x += X_FROM_DIRECTION[dir];\r\n        this.y += Y_FROM_DIRECTION[dir];\r\n        return this;\r\n    };\r\n    Offset.prototype.addCardinalDirection = function (dir) {\r\n        this.x += X_FROM_DIRECTION[dir];\r\n        this.y += Y_FROM_DIRECTION[dir];\r\n        return this;\r\n    };\r\n    Offset.prototype.subtractOffset = function (off) {\r\n        this.x -= off.x;\r\n        this.y -= off.y;\r\n        return this;\r\n    };\r\n    Offset.prototype.multiply = function (factor) {\r\n        this.x *= factor;\r\n        this.y *= factor;\r\n        return this;\r\n    };\r\n    // utilities\r\n    // chebyshev: can move in any direction (diagonals are ok)\r\n    Offset.prototype.distanceChebyshev = function (other) {\r\n        return this.subtractOffset(other).magnitudeChebyshev;\r\n    };\r\n    // manhattan: can move only in cardinal directions (no diagonals)\r\n    Offset.prototype.distanceManhattan = function (other) {\r\n        return this.subtractOffset(other).magnitudeManhattan;\r\n    };\r\n    return Offset;\r\n}());\r\nexports.Offset = Offset;\r\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar geom = __webpack_require__(0);\r\nvar LOCAL_OFF = new geom.Offset();\r\nfunction sortedInsert(array, value) {\r\n    var low = 0;\r\n    var high = array.length;\r\n    while (low < high) {\r\n        // tslint:disable-next-line:no-bitwise\r\n        var mid = (low + high) >>> 1;\r\n        if (array[mid] < value) {\r\n            low = mid + 1;\r\n        }\r\n        else {\r\n            high = mid;\r\n        }\r\n    }\r\n    array.splice(low, 0, value);\r\n}\r\nvar Path = (function () {\r\n    function Path(start, segments) {\r\n        this.start = new geom.Offset();\r\n        if (typeof start !== 'undefined') {\r\n            this.start.copyFrom(start);\r\n        }\r\n        if (typeof segments === 'undefined') {\r\n            segments = new Array();\r\n        }\r\n        this.segments = segments;\r\n    }\r\n    Path.prototype.toString = function () {\r\n        return this.start.toString() + \":\"\r\n            + (\"\" + this.segments.map(function (segment) { return geom.directionToString(segment); }).join(''));\r\n    };\r\n    Path.prototype.getIsClosed = function () {\r\n        LOCAL_OFF.copyFrom(this.start);\r\n        for (var _i = 0, _a = this.segments; _i < _a.length; _i++) {\r\n            var segment = _a[_i];\r\n            LOCAL_OFF.addDirection(segment);\r\n        }\r\n        return this.start.equals(LOCAL_OFF);\r\n    };\r\n    Path.prototype.getOffsets = function (callback) {\r\n        var cursor = new geom.Offset();\r\n        cursor.copyFrom(this.start);\r\n        callback(cursor);\r\n        for (var _i = 0, _a = this.segments; _i < _a.length; _i++) {\r\n            var segment = _a[_i];\r\n            cursor.addDirection(segment);\r\n            callback(cursor);\r\n        }\r\n    };\r\n    Path.prototype.getBounds = function () {\r\n        var northY = this.start.y;\r\n        var southY = northY;\r\n        var westX = this.start.x;\r\n        var eastX = westX;\r\n        LOCAL_OFF.copyFrom(this.start);\r\n        for (var _i = 0, _a = this.segments; _i < _a.length; _i++) {\r\n            var segment = _a[_i];\r\n            LOCAL_OFF.addDirection(segment);\r\n            switch (segment) {\r\n                case geom.Direction.NORTH:\r\n                    northY = Math.min(northY, LOCAL_OFF.y);\r\n                    break;\r\n                case geom.Direction.EAST:\r\n                    eastX = Math.max(eastX, LOCAL_OFF.x);\r\n                    break;\r\n                case geom.Direction.SOUTH:\r\n                    southY = Math.max(southY, LOCAL_OFF.y);\r\n                    break;\r\n                case geom.Direction.WEST:\r\n                    westX = Math.min(westX, LOCAL_OFF.x);\r\n                    break;\r\n            }\r\n        }\r\n        return new geom.Rectangle(westX, northY, eastX - westX + 1, southY - northY + 1);\r\n    };\r\n    Path.prototype.rasterize = function (bounds) {\r\n        var lines = new Array();\r\n        if (typeof bounds === 'undefined') {\r\n            bounds = this.getBounds();\r\n        }\r\n        LOCAL_OFF.copyFrom(this.start);\r\n        var northY = bounds.northY;\r\n        var southY = northY + bounds.height - 1;\r\n        for (var y = northY; y < southY; y++) {\r\n            lines.push([]);\r\n        }\r\n        LOCAL_OFF.copyFrom(this.start);\r\n        for (var _i = 0, _a = this.segments; _i < _a.length; _i++) {\r\n            var segment = _a[_i];\r\n            if (segment === geom.Direction.SOUTH) {\r\n                sortedInsert(lines[LOCAL_OFF.y - northY], LOCAL_OFF.x);\r\n            }\r\n            LOCAL_OFF.addDirection(segment);\r\n            if (segment === geom.Direction.NORTH) {\r\n                sortedInsert(lines[LOCAL_OFF.y - northY], LOCAL_OFF.x);\r\n            }\r\n        }\r\n        return new geom.RasterMask({\r\n            westX: bounds.westX,\r\n            northY: bounds.northY,\r\n            width: bounds.width - 1,\r\n            height: bounds.height - 1,\r\n        }, lines);\r\n    };\r\n    return Path;\r\n}());\r\nexports.Path = Path;\r\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar geom = __webpack_require__(0);\r\nvar RasterMask = (function () {\r\n    function RasterMask(bounds, lines) {\r\n        this.northWest = new geom.Offset(bounds.westX, bounds.northY);\r\n        this.size = new geom.Size(bounds.width, bounds.height);\r\n        this._lines = lines;\r\n    }\r\n    RasterMask.prototype.toString = function () {\r\n        var shape = '';\r\n        for (var y = 0; y < this.height; y++) {\r\n            var line = this._lines[y];\r\n            var x = this.westX;\r\n            for (var i = 0; i < line.length; i += 2) {\r\n                var start = line[i];\r\n                var end = line[i + 1];\r\n                while (x < start) {\r\n                    shape += '∙';\r\n                    x++;\r\n                }\r\n                while (x < end) {\r\n                    shape += '█';\r\n                    x++;\r\n                }\r\n            }\r\n            while (x <= this.eastX) {\r\n                shape += '∙';\r\n                x++;\r\n            }\r\n            shape += '\\n';\r\n        }\r\n        return this.northWest + \"\\n\" + shape;\r\n    };\r\n    Object.defineProperty(RasterMask.prototype, \"northY\", {\r\n        // accessors\r\n        get: function () {\r\n            return this.northWest.y;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(RasterMask.prototype, \"southY\", {\r\n        get: function () {\r\n            return this.northWest.y + this.size.height - 1;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(RasterMask.prototype, \"westX\", {\r\n        get: function () {\r\n            return this.northWest.x;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(RasterMask.prototype, \"eastX\", {\r\n        get: function () {\r\n            return this.northWest.x + this.size.width - 1;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(RasterMask.prototype, \"width\", {\r\n        get: function () {\r\n            return this.size.width;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(RasterMask.prototype, \"height\", {\r\n        get: function () {\r\n            return this.size.height;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    RasterMask.prototype.get = function (x, y) {\r\n        if (y < this.northY || y > this.southY) {\r\n            return false;\r\n        }\r\n        var line = this._lines[y - this.northY];\r\n        for (var i = 0; i < line.length; i += 2) {\r\n            if (x >= line[i] && x < line[i + 1]) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    RasterMask.prototype.bandsAt = function (y, callback) {\r\n        if (y < this.northY || y > this.southY) {\r\n            return;\r\n        }\r\n        var line = this._lines[y - this.northY];\r\n        for (var i = 0; i < line.length; i += 2) {\r\n            callback(line[i], line[i + 1] - 1);\r\n        }\r\n    };\r\n    return RasterMask;\r\n}());\r\nexports.RasterMask = RasterMask;\r\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar geom = __webpack_require__(0);\r\nvar LOCAL_OFF = new geom.Offset();\r\nvar Rectangle = (function () {\r\n    function Rectangle(westX, northY, width, height) {\r\n        if (typeof westX === 'undefined') {\r\n            westX = 0;\r\n        }\r\n        if (typeof northY === 'undefined') {\r\n            northY = 0;\r\n        }\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        this.northWest = new geom.Offset(westX, northY);\r\n        this.size = new geom.Size(width, height);\r\n    }\r\n    // accessors\r\n    Rectangle.prototype.toString = function () {\r\n        return \"(\" + this.westX + \",\" + this.northY + \" \" + this.width + \"x\" + this.height + \")\";\r\n    };\r\n    Rectangle.prototype.equals = function (other) {\r\n        return this.westX === other.westX && this.northY === other.northY && this.size.equals(other);\r\n    };\r\n    Object.defineProperty(Rectangle.prototype, \"northY\", {\r\n        get: function () {\r\n            return this.northWest.y;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Rectangle.prototype, \"southY\", {\r\n        get: function () {\r\n            return this.northWest.y + this.size.height - 1;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Rectangle.prototype, \"westX\", {\r\n        get: function () {\r\n            return this.northWest.x;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Rectangle.prototype, \"eastX\", {\r\n        get: function () {\r\n            return this.northWest.x + this.size.width - 1;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Rectangle.prototype, \"width\", {\r\n        get: function () {\r\n            return this.size.width;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Rectangle.prototype, \"height\", {\r\n        get: function () {\r\n            return this.size.height;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Rectangle.prototype, \"empty\", {\r\n        get: function () {\r\n            return this.size.empty;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Rectangle.prototype, \"area\", {\r\n        get: function () {\r\n            return this.size.area;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    // mutators\r\n    Rectangle.prototype.set = function (westX, northY, width, height) {\r\n        this.northWest.set(westX, northY);\r\n        this.size.set(width, height);\r\n        return this;\r\n    };\r\n    Rectangle.prototype.copyFrom = function (other) {\r\n        this.northWest.set(other.westX, other.northY);\r\n        this.size.set(other.width, other.height);\r\n        return this;\r\n    };\r\n    Rectangle.prototype.extendToInclude = function (off) {\r\n        var dx = off.x - this.westX;\r\n        if (dx < 0) {\r\n            this.size.width -= dx;\r\n            this.northWest.x = off.x;\r\n        }\r\n        else if (dx >= this.size.width) {\r\n            this.size.width = dx + 1;\r\n        }\r\n        var dy = off.y - this.northWest.y;\r\n        if (dy < 0) {\r\n            this.size.height -= dy;\r\n            this.northWest.y = off.y;\r\n        }\r\n        else if (dy >= this.size.height) {\r\n            this.size.height = dy + 1;\r\n        }\r\n        return this;\r\n    };\r\n    // utilities\r\n    Rectangle.prototype.containsOffset = function (off) {\r\n        return this.size.containsOffset(LOCAL_OFF.copyFrom(off).subtractOffset(this.northWest));\r\n    };\r\n    Rectangle.prototype.containsRectangle = function (other) {\r\n        LOCAL_OFF.set(other.westX, other.northY).subtractOffset(this.northWest);\r\n        if (!this.size.containsOffset(LOCAL_OFF)) {\r\n            return false;\r\n        }\r\n        if (other.width === 0 && other.height === 0) {\r\n            return false;\r\n        }\r\n        return this.size.containsOffset(LOCAL_OFF.add(other.width - 1, other.height - 1));\r\n    };\r\n    Rectangle.prototype.overlapsRectangle = function (other) {\r\n        return this.northY <= other.northY + other.height - 1\r\n            && this.southY >= other.northY\r\n            && this.westX <= other.westX + other.width - 1\r\n            && this.eastX >= other.westX\r\n            && !this.empty\r\n            && other.width !== 0 && other.height !== 0;\r\n    };\r\n    Rectangle.prototype.index = function (off) {\r\n        return this.size.index(LOCAL_OFF.copyFrom(off).subtractOffset(this.northWest));\r\n    };\r\n    return Rectangle;\r\n}());\r\nexports.Rectangle = Rectangle;\r\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Size = (function () {\r\n    function Size(width, height) {\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n    // accessors\r\n    Size.prototype.toString = function () {\r\n        return \"(\" + this.width + \"x\" + this.height + \")\";\r\n    };\r\n    Size.prototype.equals = function (other) {\r\n        return this.width === other.width && this.height === other.height;\r\n    };\r\n    Object.defineProperty(Size.prototype, \"empty\", {\r\n        get: function () {\r\n            return this.width === 0 || this.height === 0;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Size.prototype, \"area\", {\r\n        get: function () {\r\n            return this.width * this.height;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    // mutators\r\n    Size.prototype.set = function (width, height) {\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    };\r\n    Size.prototype.copyFrom = function (other) {\r\n        this.width = other.width;\r\n        this.height = other.height;\r\n        return this;\r\n    };\r\n    Size.prototype.add = function (width, height) {\r\n        this.width += width;\r\n        this.height += height;\r\n        return this;\r\n    };\r\n    Size.prototype.addOffset = function (off) {\r\n        this.width += off.x;\r\n        this.height += off.y;\r\n        return this;\r\n    };\r\n    Size.prototype.multiply = function (factor) {\r\n        this.width *= factor;\r\n        this.height *= factor;\r\n        return this;\r\n    };\r\n    // TODO: rotate\r\n    // utilities\r\n    Size.prototype.containsOffset = function (off) {\r\n        return off.x >= 0 && off.y >= 0 && off.x < this.width && off.y < this.height;\r\n    };\r\n    Size.prototype.index = function (off) {\r\n        return off.y * this.width + off.x;\r\n    };\r\n    return Size;\r\n}());\r\nexports.Size = Size;\r\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\n/*\r\n *  WallyFOV\r\n *  github.com/sbj42/WallyFOV\r\n *  James Clark\r\n *  Licensed under the MIT license.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar block_fractal_1 = __webpack_require__(1);\r\nexports.makeBlockFractal = block_fractal_1.makeBlockFractal;\r\nvar geom_1 = __webpack_require__(0);\r\nexports.Direction = geom_1.Direction;\r\nexports.DirectionFlags = geom_1.DirectionFlags;\r\nexports.Offset = geom_1.Offset;\r\nexports.Path = geom_1.Path;\r\nexports.RasterMask = geom_1.RasterMask;\r\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// block-fractal-0.1.0.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/bin/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 11);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap cff34591ea85cb3ccb78","export * from './direction';\r\nexport * from './direction-flags';\r\nexport * from './offset';\r\nexport * from './size';\r\nexport * from './rectangle';\r\nexport * from './mask';\r\nexport * from './mask-rect';\r\nexport * from './raster-mask';\r\nexport * from './path';\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/geom/index.ts","import * as geom from './geom';\r\n\r\nexport interface BlockFractalParam {\r\n    random?: () => number;\r\n    iterations: number;\r\n    shape?: geom.Path;\r\n    variation?: number;\r\n}\r\n\r\nfunction nextToLastMatch(points: geom.Offset[], next: geom.Offset) {\r\n    return points.length > 1 && points[points.length - 2].equals(next);\r\n}\r\n\r\nfunction addPoint(points: geom.Offset[], mask: geom.MaskRect, next: geom.Offset) {\r\n    if (nextToLastMatch(points, next)) {\r\n        mask.set(points.splice(points.length - 1, 1)[0], false);\r\n    } else {\r\n        points.push(next);\r\n        mask.set(next, true);\r\n    }\r\n}\r\n\r\nfunction verticalHelper(points: geom.Offset[], random: () => number, variation: number,\r\n                        newPoints: geom.Offset[], mask: geom.MaskRect, i: number,\r\n                        p1: geom.Offset, p2: geom.Offset) {\r\n    const x = 2 * p1.x;\r\n    const yDir = p2.y - p1.y;\r\n    for (let y = 2 * p1.y; y !== 2 * p2.y; y += yDir) {\r\n        const np3 = new geom.Offset(x, y + yDir);\r\n        // console.info(`- ${np3}`);\r\n        if (nextToLastMatch(newPoints, np3)) {\r\n            // This can happen around a corner, when just before the corner\r\n            // we dip into the corner\r\n            // console.info(` remove ${newPoints[newPoints.length - 1]}`);\r\n            mask.set(newPoints.splice(newPoints.length - 1, 1)[0], false);\r\n            continue;\r\n        }\r\n        if (i === points.length - 2 && mask.get(np3)) {\r\n            // This can happen if the first point was on a corner and the\r\n            // first move was to dip into the corner\r\n            const index = newPoints.findIndex((point) => point.equals(np3));\r\n            // console.info(`remove ${index} from beginning`);\r\n            for (const point of newPoints.splice(0, index)) {\r\n                mask.set(point, false);\r\n            }\r\n            addPoint(newPoints, mask, np3);\r\n            break;\r\n        }\r\n        if (random() < variation) {\r\n            const v = Math.floor(random() * 2) * 2 - 1;\r\n            const np1 = new geom.Offset(x + v, y);\r\n            const np2 = new geom.Offset(x + v, y + yDir);\r\n            if (!mask.get(np1) && !mask.get(np2)) {\r\n                addPoint(newPoints, mask, np1);\r\n                addPoint(newPoints, mask, np2);\r\n            }\r\n        }\r\n        addPoint(newPoints, mask, np3);\r\n    }\r\n}\r\n\r\nfunction horizontalHelper(points: geom.Offset[], random: () => number, variation: number,\r\n                          newPoints: geom.Offset[], mask: geom.MaskRect, i: number,\r\n                          p1: geom.Offset, p2: geom.Offset) {\r\n    const y = 2 * p1.y;\r\n    const xDir = p2.x - p1.x;\r\n    for (let x = 2 * p1.x; x !== 2 * p2.x; x += xDir) {\r\n        const np3 = new geom.Offset(x + xDir, y);\r\n        // console.info(`- ${np3}`);\r\n        if (nextToLastMatch(newPoints, np3)) {\r\n            // This can happen around a corner, when just before the corner\r\n            // we dip in the direction of the corner\r\n            // console.info(` remove ${newPoints[newPoints.length - 1]}`);\r\n            mask.set(newPoints.splice(newPoints.length - 1, 1)[0], false);\r\n            continue;\r\n        }\r\n        if (i === points.length - 2 && mask.get(np3)) {\r\n            // This can happen if the first point was on a corner and the\r\n            // first move was to dip into the corner\r\n            const index = newPoints.findIndex((point) => point.equals(np3));\r\n            // console.info(`remove ${index} from beginning`);\r\n            for (const point of newPoints.splice(0, index)) {\r\n                mask.set(point, false);\r\n            }\r\n            addPoint(newPoints, mask, np3);\r\n            break;\r\n        }\r\n        if (random() < variation) {\r\n            const v = Math.floor(random() * 2) * 2 - 1;\r\n            const np1 = new geom.Offset(x, y + v);\r\n            const np2 = new geom.Offset(x + xDir, y + v);\r\n            if (!mask.get(np1) && !mask.get(np2)) {\r\n                addPoint(newPoints, mask, np1);\r\n                addPoint(newPoints, mask, np2);\r\n            }\r\n        }\r\n        addPoint(newPoints, mask, np3);\r\n    }\r\n}\r\n\r\nfunction blockFractalIteration(random: () => number, points: geom.Offset[],\r\n                               bounds: geom.RectangleLike, variation: number) {\r\n    const newPoints = new Array<geom.Offset>();\r\n    const newBounds = new geom.Rectangle(\r\n        bounds.westX * 2 - 1,\r\n        bounds.northY * 2 - 1,\r\n        bounds.width * 2 + 2,\r\n        bounds.height * 2 + 2,\r\n    );\r\n    // console.info(` bounds ${newBounds}`);\r\n    const mask = new geom.MaskRect(newBounds);\r\n    for (let i = 0; i < points.length - 1; i ++) {\r\n        const p1 = points[i];\r\n        const p2 = points[i + 1];\r\n        if (i === 0) {\r\n            addPoint(newPoints, mask, new geom.Offset(p1.x * 2, p1.y * 2));\r\n        }\r\n        if (p1.x === p2.x) {\r\n            verticalHelper(points, random, variation, newPoints, mask, i, p1, p2);\r\n        } else {\r\n            horizontalHelper(points, random, variation, newPoints, mask, i, p1, p2);\r\n        }\r\n    }\r\n    return {\r\n        points: newPoints,\r\n        bounds: newBounds,\r\n    };\r\n}\r\n\r\nexport function makeBlockFractal(param: BlockFractalParam): geom.Path {\r\n    let {random, shape, variation} = param;\r\n    if (typeof random === 'undefined') {\r\n        random = Math.random;\r\n    }\r\n    if (typeof shape === 'undefined') {\r\n        shape = new geom.Path({x: -1, y: -1}, [\r\n            geom.Direction.EAST,\r\n            geom.Direction.EAST,\r\n            geom.Direction.SOUTH,\r\n            geom.Direction.SOUTH,\r\n            geom.Direction.WEST,\r\n            geom.Direction.WEST,\r\n            geom.Direction.NORTH,\r\n            geom.Direction.NORTH,\r\n        ]);\r\n    }\r\n    if (typeof variation === 'undefined') {\r\n        variation = 0.4;\r\n    }\r\n\r\n    let points = new Array<geom.Offset>();\r\n    let bounds = shape.getBounds();\r\n    shape.getOffsets((off) => {\r\n        points.push(new geom.Offset(off.x, off.y));\r\n    });\r\n\r\n    for (let iter = 0; iter < param.iterations; iter ++) {\r\n        // console.info(`iteration ${iter + 1}`);\r\n        ({points, bounds} = blockFractalIteration(random, points, bounds, variation));\r\n    }\r\n\r\n    const segments = new Array<geom.Direction>();\r\n    for (let i = 0; i < points.length - 1; i ++) {\r\n        const curPoint = points[i];\r\n        const nextPoint = points[i + 1];\r\n        if (nextPoint.y === curPoint.y - 1) {\r\n            segments.push(geom.Direction.NORTH);\r\n        } else if (nextPoint.x === curPoint.x + 1) {\r\n            segments.push(geom.Direction.EAST);\r\n        } else if (nextPoint.y === curPoint.y + 1) {\r\n            segments.push(geom.Direction.SOUTH);\r\n        } else if (nextPoint.x === curPoint.x - 1) {\r\n            segments.push(geom.Direction.WEST);\r\n        }\r\n    }\r\n\r\n    return new geom.Path(points[0], segments);\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/block-fractal.ts","import * as geom from '.';\r\n\r\n// tslint:disable:no-bitwise\r\n\r\nexport enum DirectionFlags {\r\n    NONE  = 0,\r\n    NORTH = 1,\r\n    EAST  = 2,\r\n    SOUTH = 4,\r\n    WEST  = 8,\r\n    ALL   = 15,\r\n}\r\n\r\nexport function directionFlagsToString(flags: DirectionFlags) {\r\n    let ret = '[';\r\n    if ((flags & DirectionFlags.NORTH) !== 0) {\r\n        ret += 'N';\r\n    }\r\n    if ((flags & DirectionFlags.EAST) !== 0) {\r\n        ret += 'E';\r\n    }\r\n    if ((flags & DirectionFlags.SOUTH) !== 0) {\r\n        ret += 'S';\r\n    }\r\n    if ((flags & DirectionFlags.WEST) !== 0) {\r\n        ret += 'W';\r\n    }\r\n    return ret + ']';\r\n}\r\n\r\n// conversion\r\n\r\nexport function directionFlagsFromDirection(dir: geom.Direction) {\r\n    return (1 << dir) as DirectionFlags;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/geom/direction-flags.ts","// tslint:disable:no-bitwise\r\n\r\nexport enum Direction {\r\n    NORTH = 0,\r\n    EAST  = 1,\r\n    SOUTH = 2,\r\n    WEST  = 3,\r\n}\r\n\r\nexport const DIRECTIONS = [\r\n    Direction.NORTH,\r\n    Direction.EAST,\r\n    Direction.SOUTH,\r\n    Direction.WEST,\r\n];\r\n\r\nconst DIRECTIONS_STR = [\r\n    'N',\r\n    'E',\r\n    'S',\r\n    'W',\r\n];\r\n\r\nexport function directionToString(dir: Direction) {\r\n    return DIRECTIONS_STR[dir];\r\n}\r\n\r\nexport function directionOpposite(dir: Direction) {\r\n    return ((dir + 2) & 3) as Direction;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/geom/direction.ts","import * as geom from '.';\r\n\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\nexport class MaskRect implements geom.RectangleLike {\r\n    private readonly _rectangle = new geom.Rectangle();\r\n    private readonly _mask: geom.Mask;\r\n    private readonly _outsideValue: boolean;\r\n\r\n    constructor(rect: geom.RectangleLike, initialValue = false, outsideValue = false) {\r\n        this._rectangle.copyFrom(rect);\r\n        this._mask = new geom.Mask(rect, initialValue);\r\n        this._outsideValue = outsideValue;\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `${this._rectangle.northWest}/${this._outsideValue}\\n${this._mask}`;\r\n    }\r\n\r\n    get westX() {\r\n        return this._rectangle.westX;\r\n    }\r\n\r\n    get northY() {\r\n        return this._rectangle.northY;\r\n    }\r\n\r\n    get width() {\r\n        return this._rectangle.width;\r\n    }\r\n\r\n    get height() {\r\n        return this._rectangle.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this._mask.index(LOCAL_OFF.copyFrom(off).subtractOffset(this._rectangle.northWest));\r\n    }\r\n\r\n    getAt(index: number) {\r\n        return this._mask.getAt(index);\r\n    }\r\n\r\n    get(off: geom.OffsetLike) {\r\n        if (!this._rectangle.containsOffset(off)) {\r\n            return this._outsideValue;\r\n        }\r\n        return this._mask.getAt(this._rectangle.index(off));\r\n    }\r\n\r\n    // mutators\r\n\r\n    setAt(index: number, value: boolean) {\r\n        this._mask.setAt(index, value);\r\n        return this;\r\n    }\r\n\r\n    set(off: geom.OffsetLike, value: boolean) {\r\n        this._mask.setAt(this._rectangle.index(off), value);\r\n        return this;\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/geom/mask-rect.ts","import * as geom from '.';\r\n\r\nexport class Mask implements geom.SizeLike {\r\n    private readonly _size = new geom.Size();\r\n    private readonly _bits: boolean[];\r\n    // TODO consider Uint8Array for bits\r\n\r\n    constructor(size: geom.SizeLike, initialValue = false) {\r\n        this._size.copyFrom(size);\r\n        this._bits = new Array<boolean>(this._size.area).fill(initialValue);\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        let ret = '';\r\n        const off = new geom.Offset();\r\n        for (let y = 0; y < this._size.height; y ++) {\r\n            for (let x = 0; x < this._size.width; x ++) {\r\n                off.set(x, y);\r\n                ret += this.get(off.set(x, y)) ? '☑' : '☐';\r\n            }\r\n            ret += '\\n';\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    get width() {\r\n        return this._size.width;\r\n    }\r\n\r\n    get height() {\r\n        return this._size.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this._size.index(off);\r\n    }\r\n\r\n    getAt(index: number) {\r\n        return this._bits[index];\r\n    }\r\n\r\n    get(off: geom.OffsetLike) {\r\n        return this.getAt(this.index(off));\r\n    }\r\n\r\n    // mutators\r\n\r\n    setAt(index: number, value: boolean) {\r\n        this._bits[index] = value;\r\n        return this;\r\n    }\r\n\r\n    set(off: geom.OffsetLike, value: boolean) {\r\n        return this.setAt(this.index(off), value);\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/geom/mask.ts","import * as geom from '.';\r\n\r\nconst X_FROM_DIRECTION = [  0, 1, 0, -1 ];\r\nconst Y_FROM_DIRECTION = [ -1, 0, 1,  0 ];\r\n\r\nexport interface OffsetLike {\r\n    readonly x: number;\r\n    readonly y: number;\r\n}\r\n\r\nexport class Offset implements OffsetLike {\r\n    x: number;\r\n    y: number;\r\n\r\n    constructor();\r\n    constructor(x: number, y: number);\r\n    constructor(x?: number, y?: number) {\r\n        if (typeof x === 'undefined') {\r\n            x = 0;\r\n        }\r\n        if (typeof y === 'undefined') {\r\n            y = 0;\r\n        }\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `(${this.x},${this.y})`;\r\n    }\r\n\r\n    equals(other: OffsetLike) {\r\n        return this.x === other.x && this.y === other.y;\r\n    }\r\n\r\n    // chebyshev: can move in any direction (diagonals are ok)\r\n    get magnitudeChebyshev() {\r\n        return Math.max(Math.abs(this.x), Math.abs(this.y));\r\n    }\r\n\r\n    // manhattan: can move only in cardinal directions (no diagonals)\r\n    get magnitudeManhattan(): number {\r\n        return Math.abs(this.x) + Math.abs(this.y);\r\n    }\r\n\r\n    // mutators\r\n\r\n    set(x: number, y: number) {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n\r\n    copyFrom(other: OffsetLike) {\r\n        this.x = other.x;\r\n        this.y = other.y;\r\n        return this;\r\n    }\r\n\r\n    setFromDirection(dir: geom.Direction) {\r\n        this.x = X_FROM_DIRECTION[dir];\r\n        this.y = Y_FROM_DIRECTION[dir];\r\n        return this;\r\n    }\r\n\r\n    add(x: number, y: number) {\r\n        this.x += x;\r\n        this.y += y;\r\n        return this;\r\n    }\r\n\r\n    addSize(size: geom.SizeLike) {\r\n        this.x += size.width;\r\n        this.y += size.height;\r\n        return this;\r\n    }\r\n\r\n    addOffset(off: OffsetLike) {\r\n        this.x += off.x;\r\n        this.y += off.y;\r\n        return this;\r\n    }\r\n\r\n    addDirection(dir: geom.Direction) {\r\n        this.x += X_FROM_DIRECTION[dir];\r\n        this.y += Y_FROM_DIRECTION[dir];\r\n        return this;\r\n    }\r\n\r\n    addCardinalDirection(dir: geom.Direction) {\r\n        this.x += X_FROM_DIRECTION[dir];\r\n        this.y += Y_FROM_DIRECTION[dir];\r\n        return this;\r\n    }\r\n\r\n    subtractOffset(off: OffsetLike) {\r\n        this.x -= off.x;\r\n        this.y -= off.y;\r\n        return this;\r\n    }\r\n\r\n    multiply(factor: number) {\r\n        this.x *= factor;\r\n        this.y *= factor;\r\n        return this;\r\n    }\r\n\r\n    // utilities\r\n\r\n    // chebyshev: can move in any direction (diagonals are ok)\r\n    distanceChebyshev(other: OffsetLike) {\r\n        return this.subtractOffset(other).magnitudeChebyshev;\r\n    }\r\n\r\n    // manhattan: can move only in cardinal directions (no diagonals)\r\n    distanceManhattan(other?: OffsetLike): number {\r\n        return this.subtractOffset(other).magnitudeManhattan;\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/geom/offset.ts","import * as geom from '.';\r\n\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\nfunction sortedInsert(array: number[], value: number) {\r\n    let low = 0;\r\n    let high = array.length;\r\n\r\n    while (low < high) {\r\n        // tslint:disable-next-line:no-bitwise\r\n        const mid = (low + high) >>> 1;\r\n        if (array[mid] < value) {\r\n            low = mid + 1;\r\n        } else {\r\n            high = mid;\r\n        }\r\n    }\r\n\r\n    array.splice(low, 0, value);\r\n}\r\n\r\nexport class Path {\r\n    start: geom.Offset;\r\n    segments: geom.Direction[];\r\n\r\n    constructor();\r\n    constructor(start: geom.OffsetLike, segments: geom.Direction[]);\r\n    constructor(start?: geom.OffsetLike, segments?: geom.Direction[]) {\r\n        this.start = new geom.Offset();\r\n        if (typeof start !== 'undefined') {\r\n            this.start.copyFrom(start);\r\n        }\r\n        if (typeof segments === 'undefined') {\r\n            segments = new Array<geom.Direction>();\r\n        }\r\n        this.segments = segments;\r\n    }\r\n\r\n    toString() {\r\n        return `${this.start.toString()}:`\r\n            + `${this.segments.map((segment) => geom.directionToString(segment)).join('')}`;\r\n    }\r\n\r\n    getIsClosed() {\r\n        LOCAL_OFF.copyFrom(this.start);\r\n        for (const segment of this.segments) {\r\n            LOCAL_OFF.addDirection(segment);\r\n        }\r\n        return this.start.equals(LOCAL_OFF);\r\n    }\r\n\r\n    getOffsets(callback: (off: geom.OffsetLike) => void) {\r\n        const cursor = new geom.Offset();\r\n        cursor.copyFrom(this.start);\r\n        callback(cursor);\r\n        for (const segment of this.segments) {\r\n            cursor.addDirection(segment);\r\n            callback(cursor);\r\n        }\r\n    }\r\n\r\n    getBounds(): geom.Rectangle {\r\n        let northY = this.start.y;\r\n        let southY = northY;\r\n        let westX = this.start.x;\r\n        let eastX = westX;\r\n        LOCAL_OFF.copyFrom(this.start);\r\n        for (const segment of this.segments) {\r\n            LOCAL_OFF.addDirection(segment);\r\n            switch (segment) {\r\n            case geom.Direction.NORTH:\r\n                northY = Math.min(northY, LOCAL_OFF.y);\r\n                break;\r\n            case geom.Direction.EAST:\r\n                eastX = Math.max(eastX, LOCAL_OFF.x);\r\n                break;\r\n            case geom.Direction.SOUTH:\r\n                southY = Math.max(southY, LOCAL_OFF.y);\r\n                break;\r\n            case geom.Direction.WEST:\r\n                westX = Math.min(westX, LOCAL_OFF.x);\r\n                break;\r\n            }\r\n        }\r\n        return new geom.Rectangle(westX, northY, eastX - westX + 1, southY - northY + 1);\r\n    }\r\n\r\n    rasterize(bounds?: geom.RectangleLike): geom.RasterMask {\r\n        const lines = new Array<number[]>();\r\n        if (typeof bounds === 'undefined') {\r\n            bounds = this.getBounds();\r\n        }\r\n        LOCAL_OFF.copyFrom(this.start);\r\n        const {northY} = bounds;\r\n        const southY = northY + bounds.height - 1;\r\n        for (let y = northY; y < southY; y ++) {\r\n            lines.push([]);\r\n        }\r\n        LOCAL_OFF.copyFrom(this.start);\r\n        for (const segment of this.segments) {\r\n            if (segment === geom.Direction.SOUTH) {\r\n                sortedInsert(lines[LOCAL_OFF.y - northY], LOCAL_OFF.x);\r\n            }\r\n            LOCAL_OFF.addDirection(segment);\r\n            if (segment === geom.Direction.NORTH) {\r\n                sortedInsert(lines[LOCAL_OFF.y - northY], LOCAL_OFF.x);\r\n            }\r\n        }\r\n        return new geom.RasterMask({\r\n            westX: bounds.westX,\r\n            northY: bounds.northY,\r\n            width: bounds.width - 1,\r\n            height: bounds.height - 1,\r\n        }, lines);\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/geom/path.ts","import * as geom from '.';\r\n\r\nexport class RasterMask implements geom.RectangleLike, geom.SizeLike {\r\n    northWest: geom.Offset;\r\n    size: geom.Size;\r\n    private _lines: number[][];\r\n\r\n    constructor(bounds: geom.RectangleLike, lines: number[][]) {\r\n        this.northWest = new geom.Offset(bounds.westX, bounds.northY);\r\n        this.size = new geom.Size(bounds.width, bounds.height);\r\n        this._lines = lines;\r\n    }\r\n\r\n    toString() {\r\n        let shape = '';\r\n        for (let y = 0; y < this.height; y ++) {\r\n            const line = this._lines[y];\r\n            let x = this.westX;\r\n            for (let i = 0; i < line.length; i += 2) {\r\n                const start = line[i];\r\n                const end = line[i + 1];\r\n                while (x < start) {\r\n                    shape += '∙';\r\n                    x ++;\r\n                }\r\n                while (x < end) {\r\n                    shape += '█';\r\n                    x ++;\r\n                }\r\n            }\r\n            while (x <= this.eastX) {\r\n                shape += '∙';\r\n                x ++;\r\n            }\r\n            shape += '\\n';\r\n        }\r\n        return `${this.northWest}\\n${shape}`;\r\n    }\r\n\r\n    // accessors\r\n\r\n    get northY() {\r\n        return this.northWest.y;\r\n    }\r\n\r\n    get southY() {\r\n        return this.northWest.y + this.size.height - 1;\r\n    }\r\n\r\n    get westX() {\r\n        return this.northWest.x;\r\n    }\r\n\r\n    get eastX() {\r\n        return this.northWest.x + this.size.width - 1;\r\n    }\r\n\r\n    get width() {\r\n        return this.size.width;\r\n    }\r\n\r\n    get height() {\r\n        return this.size.height;\r\n    }\r\n\r\n    get(x: number, y: number) {\r\n        if (y < this.northY || y > this.southY) {\r\n            return false;\r\n        }\r\n        const line = this._lines[y - this.northY];\r\n        for (let i = 0; i < line.length; i += 2) {\r\n            if (x >= line[i] && x < line[i + 1]) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    bandsAt(y: number, callback: (westX: number, eastX: number) => void) {\r\n        if (y < this.northY || y > this.southY) {\r\n            return;\r\n        }\r\n        const line = this._lines[y - this.northY];\r\n        for (let i = 0; i < line.length; i += 2) {\r\n            callback(line[i], line[i + 1] - 1);\r\n        }\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/geom/raster-mask.ts","import * as geom from '.';\r\n\r\nexport interface RectangleLike extends geom.SizeLike {\r\n    readonly westX: number;\r\n    readonly northY: number;\r\n}\r\n\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\nexport class Rectangle implements RectangleLike, geom.SizeLike {\r\n    northWest: geom.Offset;\r\n    size: geom.Size;\r\n\r\n    constructor();\r\n    constructor(westX: number, northY: number, width: number, height: number);\r\n    constructor(westX?: number, northY?: number, width?: number, height?: number) {\r\n        if (typeof westX === 'undefined') {\r\n            westX = 0;\r\n        }\r\n        if (typeof northY === 'undefined') {\r\n            northY = 0;\r\n        }\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        this.northWest = new geom.Offset(westX, northY);\r\n        this.size = new geom.Size(width, height);\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `(${this.westX},${this.northY} ${this.width}x${this.height})`;\r\n    }\r\n\r\n    equals(other: RectangleLike) {\r\n        return this.westX === other.westX && this.northY === other.northY && this.size.equals(other);\r\n    }\r\n\r\n    get northY() {\r\n        return this.northWest.y;\r\n    }\r\n\r\n    get southY() {\r\n        return this.northWest.y + this.size.height - 1;\r\n    }\r\n\r\n    get westX() {\r\n        return this.northWest.x;\r\n    }\r\n\r\n    get eastX() {\r\n        return this.northWest.x + this.size.width - 1;\r\n    }\r\n\r\n    get width() {\r\n        return this.size.width;\r\n    }\r\n\r\n    get height() {\r\n        return this.size.height;\r\n    }\r\n\r\n    get empty() {\r\n        return this.size.empty;\r\n    }\r\n\r\n    get area() {\r\n        return this.size.area;\r\n    }\r\n\r\n    // mutators\r\n\r\n    set(westX: number, northY: number, width: number, height: number) {\r\n        this.northWest.set(westX, northY);\r\n        this.size.set(width, height);\r\n        return this;\r\n    }\r\n\r\n    copyFrom(other: RectangleLike) {\r\n        this.northWest.set(other.westX, other.northY);\r\n        this.size.set(other.width, other.height);\r\n        return this;\r\n    }\r\n\r\n    extendToInclude(off: geom.OffsetLike) {\r\n        const dx = off.x - this.westX;\r\n        if (dx < 0) {\r\n            this.size.width -= dx;\r\n            this.northWest.x = off.x;\r\n        } else if (dx >= this.size.width) {\r\n            this.size.width = dx + 1;\r\n        }\r\n        const dy = off.y - this.northWest.y;\r\n        if (dy < 0) {\r\n            this.size.height -= dy;\r\n            this.northWest.y = off.y;\r\n        } else if (dy >= this.size.height) {\r\n            this.size.height = dy + 1;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // utilities\r\n\r\n    containsOffset(off: geom.OffsetLike) {\r\n        return this.size.containsOffset(LOCAL_OFF.copyFrom(off).subtractOffset(this.northWest));\r\n    }\r\n\r\n    containsRectangle(other: RectangleLike) {\r\n        LOCAL_OFF.set(other.westX, other.northY).subtractOffset(this.northWest);\r\n        if (!this.size.containsOffset(LOCAL_OFF)) {\r\n            return false;\r\n        }\r\n        if (other.width === 0 && other.height === 0) {\r\n            return false;\r\n        }\r\n        return this.size.containsOffset(LOCAL_OFF.add(other.width - 1, other.height - 1));\r\n    }\r\n\r\n    overlapsRectangle(other: RectangleLike) {\r\n        return this.northY <= other.northY + other.height - 1\r\n            && this.southY >= other.northY\r\n            && this.westX <= other.westX + other.width - 1\r\n            && this.eastX >= other.westX\r\n            && !this.empty\r\n            && other.width !== 0 && other.height !== 0;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this.size.index(LOCAL_OFF.copyFrom(off).subtractOffset(this.northWest));\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/geom/rectangle.ts","import * as geom from '.';\r\n\r\nexport interface SizeLike {\r\n    readonly width: number;\r\n    readonly height: number;\r\n}\r\n\r\nexport class Size implements SizeLike {\r\n    width: number;\r\n    height: number;\r\n\r\n    constructor();\r\n    constructor(width: number, height: number);\r\n    constructor(width?: number, height?: number) {\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `(${this.width}x${this.height})`;\r\n    }\r\n\r\n    equals(other: SizeLike) {\r\n        return this.width === other.width && this.height === other.height;\r\n    }\r\n\r\n    get empty() {\r\n        return this.width === 0 || this.height === 0;\r\n    }\r\n\r\n    get area() {\r\n        return this.width * this.height;\r\n    }\r\n\r\n    // mutators\r\n\r\n    set(width: number, height: number) {\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n\r\n    copyFrom(other: SizeLike) {\r\n        this.width = other.width;\r\n        this.height = other.height;\r\n        return this;\r\n    }\r\n\r\n    add(width: number, height: number) {\r\n        this.width += width;\r\n        this.height += height;\r\n        return this;\r\n    }\r\n\r\n    addOffset(off: geom.OffsetLike) {\r\n        this.width += off.x;\r\n        this.height += off.y;\r\n        return this;\r\n    }\r\n\r\n    multiply(factor: number) {\r\n        this.width *= factor;\r\n        this.height *= factor;\r\n        return this;\r\n    }\r\n\r\n    // TODO: rotate\r\n\r\n    // utilities\r\n\r\n    containsOffset(off: geom.OffsetLike) {\r\n        return off.x >= 0 && off.y >= 0 && off.x < this.width && off.y < this.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return off.y * this.width + off.x;\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/geom/size.ts","/*\r\n *  WallyFOV\r\n *  github.com/sbj42/WallyFOV\r\n *  James Clark\r\n *  Licensed under the MIT license.\r\n */\r\n\r\nexport {makeBlockFractal} from './block-fractal';\r\nexport {Direction, DirectionFlags, Offset, Path, RasterMask} from './geom';\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts"],"sourceRoot":""}
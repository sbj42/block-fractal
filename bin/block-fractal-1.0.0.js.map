{"version":3,"sources":["webpack://BlockFractal/webpack/bootstrap","webpack://BlockFractal/./src/geom/index.ts","webpack://BlockFractal/./src/geom/path.ts","webpack://BlockFractal/./src/geom/raster-mask.ts","webpack://BlockFractal/./src/geom/mask-rect.ts","webpack://BlockFractal/./src/geom/mask.ts","webpack://BlockFractal/./src/geom/rectangle.ts","webpack://BlockFractal/./src/geom/size.ts","webpack://BlockFractal/./src/geom/offset.ts","webpack://BlockFractal/./src/geom/direction-flags.ts","webpack://BlockFractal/./src/geom/direction.ts","webpack://BlockFractal/./src/block-fractal.ts","webpack://BlockFractal/./src/index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__export","geom","LOCAL_OFF","Offset","sortedInsert","array","low","high","length","mid","splice","Path","start","segments","this","copyFrom","Array","toString","map","segment","directionToString","join","getIsClosed","_i","_a","addDirection","equals","getOffsets","callback","cursor","getBounds","northY","y","southY","westX","x","eastX","Direction","NORTH","Math","min","EAST","max","SOUTH","WEST","Rectangle","getArea","total","abs","rasterize","bounds","lines","height","push","RasterMask","width","northWest","size","Size","_lines","shape","line","end","bandsAt","MaskRect","rect","initialValue","outsideValue","_rectangle","_mask","Mask","_outsideValue","index","off","subtractOffset","getAt","containsOffset","setAt","set","_size","_bits","ceil","area","fill","ret","arrayIndex","bitMask","other","empty","extendToInclude","dx","dy","containsRectangle","add","overlapsRectangle","addOffset","multiply","factor","X_FROM_DIRECTION","Y_FROM_DIRECTION","setFromDirection","dir","addSize","addCardinalDirection","distanceChebyshev","magnitudeChebyshev","distanceManhattan","magnitudeManhattan","DirectionFlags","directionFlagsToString","flags","directionFlagsFromDirection","DIRECTIONS","DIRECTIONS_STR","directionOpposite","nextToLastMatch","points","next","addPoint","mask","verticalHelper","random","variation","newPoints","p1","p2","yDir","np3","findIndex","point","v","floor","np1","np2","horizontalHelper","xDir","blockFractalIteration","newBounds","makeBlockFractal","param","iter","iterations","curPoint","nextPoint","block_fractal_1","geom_1"],"mappings":"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","file":"block-fractal-1.0.0.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/bin/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 11);\n","export * from './direction';\r\nexport * from './direction-flags';\r\nexport * from './offset';\r\nexport * from './size';\r\nexport * from './rectangle';\r\nexport * from './mask';\r\nexport * from './mask-rect';\r\nexport * from './raster-mask';\r\nexport * from './path';\r\n","import * as geom from '.';\r\n\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\nfunction sortedInsert(array: number[], value: number) {\r\n    let low = 0;\r\n    let high = array.length;\r\n\r\n    while (low < high) {\r\n        // tslint:disable-next-line:no-bitwise\r\n        const mid = (low + high) >>> 1;\r\n        if (array[mid] < value) {\r\n            low = mid + 1;\r\n        } else {\r\n            high = mid;\r\n        }\r\n    }\r\n\r\n    array.splice(low, 0, value);\r\n}\r\n\r\nexport class Path {\r\n    start: geom.Offset;\r\n    segments: geom.Direction[];\r\n\r\n    constructor();\r\n    constructor(start: geom.OffsetLike, segments: geom.Direction[]);\r\n    constructor(start?: geom.OffsetLike, segments?: geom.Direction[]) {\r\n        this.start = new geom.Offset();\r\n        if (typeof start !== 'undefined') {\r\n            this.start.copyFrom(start);\r\n        }\r\n        if (typeof segments === 'undefined') {\r\n            segments = new Array<geom.Direction>();\r\n        }\r\n        this.segments = segments;\r\n    }\r\n\r\n    toString() {\r\n        return `${this.start.toString()}:`\r\n            + `${this.segments.map((segment) => geom.directionToString(segment)).join('')}`;\r\n    }\r\n\r\n    getIsClosed() {\r\n        LOCAL_OFF.copyFrom(this.start);\r\n        for (const segment of this.segments) {\r\n            LOCAL_OFF.addDirection(segment);\r\n        }\r\n        return this.start.equals(LOCAL_OFF);\r\n    }\r\n\r\n    getOffsets(callback: (off: geom.OffsetLike) => void) {\r\n        const cursor = new geom.Offset();\r\n        cursor.copyFrom(this.start);\r\n        callback(cursor);\r\n        for (const segment of this.segments) {\r\n            cursor.addDirection(segment);\r\n            callback(cursor);\r\n        }\r\n    }\r\n\r\n    getBounds(): geom.Rectangle {\r\n        let northY = this.start.y;\r\n        let southY = northY;\r\n        let westX = this.start.x;\r\n        let eastX = westX;\r\n        LOCAL_OFF.copyFrom(this.start);\r\n        for (const segment of this.segments) {\r\n            LOCAL_OFF.addDirection(segment);\r\n            switch (segment) {\r\n            case geom.Direction.NORTH:\r\n                northY = Math.min(northY, LOCAL_OFF.y);\r\n                break;\r\n            case geom.Direction.EAST:\r\n                eastX = Math.max(eastX, LOCAL_OFF.x);\r\n                break;\r\n            case geom.Direction.SOUTH:\r\n                southY = Math.max(southY, LOCAL_OFF.y);\r\n                break;\r\n            case geom.Direction.WEST:\r\n                westX = Math.min(westX, LOCAL_OFF.x);\r\n                break;\r\n            }\r\n        }\r\n        return new geom.Rectangle(westX, northY, eastX - westX + 1, southY - northY + 1);\r\n    }\r\n\r\n    getArea() {\r\n        let total = 0;\r\n        LOCAL_OFF.copyFrom(this.start);\r\n        for (const segment of this.segments) {\r\n            LOCAL_OFF.addDirection(segment);\r\n            switch (segment) {\r\n            case geom.Direction.NORTH:\r\n                total -= LOCAL_OFF.x;\r\n                break;\r\n            case geom.Direction.SOUTH:\r\n                total += LOCAL_OFF.x;\r\n                break;\r\n            }\r\n        }\r\n        return Math.abs(total);\r\n    }\r\n\r\n    rasterize(bounds?: geom.RectangleLike): geom.RasterMask {\r\n        const lines = new Array<number[]>();\r\n        if (typeof bounds === 'undefined') {\r\n            bounds = this.getBounds();\r\n        }\r\n        LOCAL_OFF.copyFrom(this.start);\r\n        const {northY} = bounds;\r\n        const southY = northY + bounds.height - 1;\r\n        for (let y = northY; y < southY; y ++) {\r\n            lines.push([]);\r\n        }\r\n        LOCAL_OFF.copyFrom(this.start);\r\n        for (const segment of this.segments) {\r\n            if (segment === geom.Direction.SOUTH) {\r\n                sortedInsert(lines[LOCAL_OFF.y - northY], LOCAL_OFF.x);\r\n            }\r\n            LOCAL_OFF.addDirection(segment);\r\n            if (segment === geom.Direction.NORTH) {\r\n                sortedInsert(lines[LOCAL_OFF.y - northY], LOCAL_OFF.x);\r\n            }\r\n        }\r\n        return new geom.RasterMask({\r\n            westX: bounds.westX,\r\n            northY: bounds.northY,\r\n            width: bounds.width - 1,\r\n            height: bounds.height - 1,\r\n        }, lines);\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nexport class RasterMask implements geom.RectangleLike, geom.SizeLike {\r\n    northWest: geom.Offset;\r\n    size: geom.Size;\r\n    private _lines: number[][];\r\n\r\n    constructor(bounds: geom.RectangleLike, lines: number[][]) {\r\n        this.northWest = new geom.Offset(bounds.westX, bounds.northY);\r\n        this.size = new geom.Size(bounds.width, bounds.height);\r\n        this._lines = lines;\r\n    }\r\n\r\n    toString() {\r\n        let shape = '';\r\n        for (let y = 0; y < this.height; y ++) {\r\n            const line = this._lines[y];\r\n            let x = this.westX;\r\n            for (let i = 0; i < line.length; i += 2) {\r\n                const start = line[i];\r\n                const end = line[i + 1];\r\n                while (x < start) {\r\n                    shape += '∙';\r\n                    x ++;\r\n                }\r\n                while (x < end) {\r\n                    shape += '█';\r\n                    x ++;\r\n                }\r\n            }\r\n            while (x <= this.eastX) {\r\n                shape += '∙';\r\n                x ++;\r\n            }\r\n            shape += '\\n';\r\n        }\r\n        return `${this.northWest}\\n${shape}`;\r\n    }\r\n\r\n    // accessors\r\n\r\n    get northY() {\r\n        return this.northWest.y;\r\n    }\r\n\r\n    get southY() {\r\n        return this.northWest.y + this.size.height - 1;\r\n    }\r\n\r\n    get westX() {\r\n        return this.northWest.x;\r\n    }\r\n\r\n    get eastX() {\r\n        return this.northWest.x + this.size.width - 1;\r\n    }\r\n\r\n    get width() {\r\n        return this.size.width;\r\n    }\r\n\r\n    get height() {\r\n        return this.size.height;\r\n    }\r\n\r\n    get(x: number, y: number) {\r\n        if (y < this.northY || y > this.southY) {\r\n            return false;\r\n        }\r\n        const line = this._lines[y - this.northY];\r\n        for (let i = 0; i < line.length; i += 2) {\r\n            if (x >= line[i] && x < line[i + 1]) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    bandsAt(y: number, callback: (westX: number, eastX: number) => void) {\r\n        if (y < this.northY || y > this.southY) {\r\n            return;\r\n        }\r\n        const line = this._lines[y - this.northY];\r\n        for (let i = 0; i < line.length; i += 2) {\r\n            callback(line[i], line[i + 1] - 1);\r\n        }\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\nexport class MaskRect implements geom.RectangleLike {\r\n    private readonly _rectangle = new geom.Rectangle();\r\n    private readonly _mask: geom.Mask;\r\n    private readonly _outsideValue: boolean;\r\n\r\n    constructor(rect: geom.RectangleLike, initialValue = false, outsideValue = false) {\r\n        this._rectangle.copyFrom(rect);\r\n        this._mask = new geom.Mask(rect, initialValue);\r\n        this._outsideValue = outsideValue;\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `${this._rectangle.northWest}/${this._outsideValue}\\n${this._mask}`;\r\n    }\r\n\r\n    get westX() {\r\n        return this._rectangle.westX;\r\n    }\r\n\r\n    get northY() {\r\n        return this._rectangle.northY;\r\n    }\r\n\r\n    get width() {\r\n        return this._rectangle.width;\r\n    }\r\n\r\n    get height() {\r\n        return this._rectangle.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this._mask.index(LOCAL_OFF.copyFrom(off).subtractOffset(this._rectangle.northWest));\r\n    }\r\n\r\n    getAt(index: number) {\r\n        return this._mask.getAt(index);\r\n    }\r\n\r\n    get(off: geom.OffsetLike) {\r\n        if (!this._rectangle.containsOffset(off)) {\r\n            return this._outsideValue;\r\n        }\r\n        return this._mask.getAt(this._rectangle.index(off));\r\n    }\r\n\r\n    // mutators\r\n\r\n    setAt(index: number, value: boolean) {\r\n        this._mask.setAt(index, value);\r\n        return this;\r\n    }\r\n\r\n    set(off: geom.OffsetLike, value: boolean) {\r\n        this._mask.setAt(this._rectangle.index(off), value);\r\n        return this;\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nexport class Mask implements geom.SizeLike {\r\n    private readonly _size = new geom.Size();\r\n    private readonly _bits: number[];\r\n    // TODO consider Uint8Array for bits\r\n\r\n    constructor(size: geom.SizeLike, initialValue = false) {\r\n        this._size.copyFrom(size);\r\n        this._bits = new Array<number>(Math.ceil(this._size.area / 32)).fill(initialValue ? 0xffffffff : 0);\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        let ret = '';\r\n        const off = new geom.Offset();\r\n        for (let y = 0; y < this._size.height; y ++) {\r\n            for (let x = 0; x < this._size.width; x ++) {\r\n                off.set(x, y);\r\n                ret += this.get(off.set(x, y)) ? '☑' : '☐';\r\n            }\r\n            ret += '\\n';\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    get width() {\r\n        return this._size.width;\r\n    }\r\n\r\n    get height() {\r\n        return this._size.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this._size.index(off);\r\n    }\r\n\r\n    getAt(index: number) {\r\n        // tslint:disable:no-bitwise\r\n        const arrayIndex = index >>> 5;\r\n        const bitMask = 1 << (index & 31);\r\n        return (this._bits[arrayIndex] & bitMask) !== 0;\r\n        // tslint:enable:no-bitwise\r\n    }\r\n\r\n    get(off: geom.OffsetLike) {\r\n        return this.getAt(this.index(off));\r\n    }\r\n\r\n    // mutators\r\n\r\n    setAt(index: number, value: boolean) {\r\n        // tslint:disable:no-bitwise\r\n        const arrayIndex = index >>> 5;\r\n        const bitMask = 1 << (index & 31);\r\n        if (value) {\r\n            this._bits[arrayIndex] |= bitMask;\r\n        } else {\r\n            this._bits[arrayIndex] &= ~bitMask;\r\n        }\r\n        // tslint:enable:no-bitwise\r\n        return this;\r\n    }\r\n\r\n    set(off: geom.OffsetLike, value: boolean) {\r\n        return this.setAt(this.index(off), value);\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nexport interface RectangleLike extends geom.SizeLike {\r\n    readonly westX: number;\r\n    readonly northY: number;\r\n}\r\n\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\nexport class Rectangle implements RectangleLike, geom.SizeLike {\r\n    northWest: geom.Offset;\r\n    size: geom.Size;\r\n\r\n    constructor();\r\n    constructor(westX: number, northY: number, width: number, height: number);\r\n    constructor(westX?: number, northY?: number, width?: number, height?: number) {\r\n        if (typeof westX === 'undefined') {\r\n            westX = 0;\r\n        }\r\n        if (typeof northY === 'undefined') {\r\n            northY = 0;\r\n        }\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        this.northWest = new geom.Offset(westX, northY);\r\n        this.size = new geom.Size(width, height);\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `(${this.westX},${this.northY} ${this.width}x${this.height})`;\r\n    }\r\n\r\n    equals(other: RectangleLike) {\r\n        return this.westX === other.westX && this.northY === other.northY && this.size.equals(other);\r\n    }\r\n\r\n    get northY() {\r\n        return this.northWest.y;\r\n    }\r\n\r\n    get southY() {\r\n        return this.northWest.y + this.size.height - 1;\r\n    }\r\n\r\n    get westX() {\r\n        return this.northWest.x;\r\n    }\r\n\r\n    get eastX() {\r\n        return this.northWest.x + this.size.width - 1;\r\n    }\r\n\r\n    get width() {\r\n        return this.size.width;\r\n    }\r\n\r\n    get height() {\r\n        return this.size.height;\r\n    }\r\n\r\n    get empty() {\r\n        return this.size.empty;\r\n    }\r\n\r\n    get area() {\r\n        return this.size.area;\r\n    }\r\n\r\n    // mutators\r\n\r\n    set(westX: number, northY: number, width: number, height: number) {\r\n        this.northWest.set(westX, northY);\r\n        this.size.set(width, height);\r\n        return this;\r\n    }\r\n\r\n    copyFrom(other: RectangleLike) {\r\n        this.northWest.set(other.westX, other.northY);\r\n        this.size.set(other.width, other.height);\r\n        return this;\r\n    }\r\n\r\n    extendToInclude(off: geom.OffsetLike) {\r\n        const dx = off.x - this.westX;\r\n        if (dx < 0) {\r\n            this.size.width -= dx;\r\n            this.northWest.x = off.x;\r\n        } else if (dx >= this.size.width) {\r\n            this.size.width = dx + 1;\r\n        }\r\n        const dy = off.y - this.northWest.y;\r\n        if (dy < 0) {\r\n            this.size.height -= dy;\r\n            this.northWest.y = off.y;\r\n        } else if (dy >= this.size.height) {\r\n            this.size.height = dy + 1;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // utilities\r\n\r\n    containsOffset(off: geom.OffsetLike) {\r\n        return this.size.containsOffset(LOCAL_OFF.copyFrom(off).subtractOffset(this.northWest));\r\n    }\r\n\r\n    containsRectangle(other: RectangleLike) {\r\n        LOCAL_OFF.set(other.westX, other.northY).subtractOffset(this.northWest);\r\n        if (!this.size.containsOffset(LOCAL_OFF)) {\r\n            return false;\r\n        }\r\n        if (other.width === 0 && other.height === 0) {\r\n            return false;\r\n        }\r\n        return this.size.containsOffset(LOCAL_OFF.add(other.width - 1, other.height - 1));\r\n    }\r\n\r\n    overlapsRectangle(other: RectangleLike) {\r\n        return this.northY <= other.northY + other.height - 1\r\n            && this.southY >= other.northY\r\n            && this.westX <= other.westX + other.width - 1\r\n            && this.eastX >= other.westX\r\n            && !this.empty\r\n            && other.width !== 0 && other.height !== 0;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this.size.index(LOCAL_OFF.copyFrom(off).subtractOffset(this.northWest));\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nexport interface SizeLike {\r\n    readonly width: number;\r\n    readonly height: number;\r\n}\r\n\r\nexport class Size implements SizeLike {\r\n    width: number;\r\n    height: number;\r\n\r\n    constructor();\r\n    constructor(width: number, height: number);\r\n    constructor(width?: number, height?: number) {\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `(${this.width}x${this.height})`;\r\n    }\r\n\r\n    equals(other: SizeLike) {\r\n        return this.width === other.width && this.height === other.height;\r\n    }\r\n\r\n    get empty() {\r\n        return this.width === 0 || this.height === 0;\r\n    }\r\n\r\n    get area() {\r\n        return this.width * this.height;\r\n    }\r\n\r\n    // mutators\r\n\r\n    set(width: number, height: number) {\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n\r\n    copyFrom(other: SizeLike) {\r\n        this.width = other.width;\r\n        this.height = other.height;\r\n        return this;\r\n    }\r\n\r\n    add(width: number, height: number) {\r\n        this.width += width;\r\n        this.height += height;\r\n        return this;\r\n    }\r\n\r\n    addOffset(off: geom.OffsetLike) {\r\n        this.width += off.x;\r\n        this.height += off.y;\r\n        return this;\r\n    }\r\n\r\n    multiply(factor: number) {\r\n        this.width *= factor;\r\n        this.height *= factor;\r\n        return this;\r\n    }\r\n\r\n    // TODO: rotate\r\n\r\n    // utilities\r\n\r\n    containsOffset(off: geom.OffsetLike) {\r\n        return off.x >= 0 && off.y >= 0 && off.x < this.width && off.y < this.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return off.y * this.width + off.x;\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nconst X_FROM_DIRECTION = [  0, 1, 0, -1 ];\r\nconst Y_FROM_DIRECTION = [ -1, 0, 1,  0 ];\r\n\r\nexport interface OffsetLike {\r\n    readonly x: number;\r\n    readonly y: number;\r\n}\r\n\r\nexport class Offset implements OffsetLike {\r\n    x: number;\r\n    y: number;\r\n\r\n    constructor();\r\n    constructor(x: number, y: number);\r\n    constructor(x?: number, y?: number) {\r\n        if (typeof x === 'undefined') {\r\n            x = 0;\r\n        }\r\n        if (typeof y === 'undefined') {\r\n            y = 0;\r\n        }\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `(${this.x},${this.y})`;\r\n    }\r\n\r\n    equals(other: OffsetLike) {\r\n        return this.x === other.x && this.y === other.y;\r\n    }\r\n\r\n    // chebyshev: can move in any direction (diagonals are ok)\r\n    get magnitudeChebyshev() {\r\n        return Math.max(Math.abs(this.x), Math.abs(this.y));\r\n    }\r\n\r\n    // manhattan: can move only in cardinal directions (no diagonals)\r\n    get magnitudeManhattan(): number {\r\n        return Math.abs(this.x) + Math.abs(this.y);\r\n    }\r\n\r\n    // mutators\r\n\r\n    set(x: number, y: number) {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n\r\n    copyFrom(other: OffsetLike) {\r\n        this.x = other.x;\r\n        this.y = other.y;\r\n        return this;\r\n    }\r\n\r\n    setFromDirection(dir: geom.Direction) {\r\n        this.x = X_FROM_DIRECTION[dir];\r\n        this.y = Y_FROM_DIRECTION[dir];\r\n        return this;\r\n    }\r\n\r\n    add(x: number, y: number) {\r\n        this.x += x;\r\n        this.y += y;\r\n        return this;\r\n    }\r\n\r\n    addSize(size: geom.SizeLike) {\r\n        this.x += size.width;\r\n        this.y += size.height;\r\n        return this;\r\n    }\r\n\r\n    addOffset(off: OffsetLike) {\r\n        this.x += off.x;\r\n        this.y += off.y;\r\n        return this;\r\n    }\r\n\r\n    addDirection(dir: geom.Direction) {\r\n        this.x += X_FROM_DIRECTION[dir];\r\n        this.y += Y_FROM_DIRECTION[dir];\r\n        return this;\r\n    }\r\n\r\n    addCardinalDirection(dir: geom.Direction) {\r\n        this.x += X_FROM_DIRECTION[dir];\r\n        this.y += Y_FROM_DIRECTION[dir];\r\n        return this;\r\n    }\r\n\r\n    subtractOffset(off: OffsetLike) {\r\n        this.x -= off.x;\r\n        this.y -= off.y;\r\n        return this;\r\n    }\r\n\r\n    multiply(factor: number) {\r\n        this.x *= factor;\r\n        this.y *= factor;\r\n        return this;\r\n    }\r\n\r\n    // utilities\r\n\r\n    // chebyshev: can move in any direction (diagonals are ok)\r\n    distanceChebyshev(other: OffsetLike) {\r\n        return this.subtractOffset(other).magnitudeChebyshev;\r\n    }\r\n\r\n    // manhattan: can move only in cardinal directions (no diagonals)\r\n    distanceManhattan(other?: OffsetLike): number {\r\n        return this.subtractOffset(other).magnitudeManhattan;\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\n// tslint:disable:no-bitwise\r\n\r\nexport enum DirectionFlags {\r\n    NONE  = 0,\r\n    NORTH = 1,\r\n    EAST  = 2,\r\n    SOUTH = 4,\r\n    WEST  = 8,\r\n    ALL   = 15,\r\n}\r\n\r\nexport function directionFlagsToString(flags: DirectionFlags) {\r\n    let ret = '[';\r\n    if ((flags & DirectionFlags.NORTH) !== 0) {\r\n        ret += 'N';\r\n    }\r\n    if ((flags & DirectionFlags.EAST) !== 0) {\r\n        ret += 'E';\r\n    }\r\n    if ((flags & DirectionFlags.SOUTH) !== 0) {\r\n        ret += 'S';\r\n    }\r\n    if ((flags & DirectionFlags.WEST) !== 0) {\r\n        ret += 'W';\r\n    }\r\n    return ret + ']';\r\n}\r\n\r\n// conversion\r\n\r\nexport function directionFlagsFromDirection(dir: geom.Direction) {\r\n    return (1 << dir) as DirectionFlags;\r\n}\r\n","// tslint:disable:no-bitwise\r\n\r\nexport enum Direction {\r\n    NORTH = 0,\r\n    EAST  = 1,\r\n    SOUTH = 2,\r\n    WEST  = 3,\r\n}\r\n\r\nexport const DIRECTIONS = [\r\n    Direction.NORTH,\r\n    Direction.EAST,\r\n    Direction.SOUTH,\r\n    Direction.WEST,\r\n];\r\n\r\nconst DIRECTIONS_STR = [\r\n    'N',\r\n    'E',\r\n    'S',\r\n    'W',\r\n];\r\n\r\nexport function directionToString(dir: Direction) {\r\n    return DIRECTIONS_STR[dir];\r\n}\r\n\r\nexport function directionOpposite(dir: Direction) {\r\n    return ((dir + 2) & 3) as Direction;\r\n}\r\n","import * as geom from './geom';\r\n\r\nexport interface BlockFractalParam {\r\n    random?: () => number;\r\n    iterations: number;\r\n    shape?: geom.Path;\r\n    variation?: number;\r\n}\r\n\r\nfunction nextToLastMatch(points: geom.Offset[], next: geom.Offset) {\r\n    return points.length > 1 && points[points.length - 2].equals(next);\r\n}\r\n\r\nfunction addPoint(points: geom.Offset[], mask: geom.MaskRect, next: geom.Offset) {\r\n    if (nextToLastMatch(points, next)) {\r\n        mask.set(points.splice(points.length - 1, 1)[0], false);\r\n    } else {\r\n        points.push(next);\r\n        mask.set(next, true);\r\n    }\r\n}\r\n\r\nfunction verticalHelper(points: geom.Offset[], random: () => number, variation: number,\r\n                        newPoints: geom.Offset[], mask: geom.MaskRect, i: number,\r\n                        p1: geom.Offset, p2: geom.Offset) {\r\n    const x = 2 * p1.x;\r\n    const yDir = p2.y - p1.y;\r\n    for (let y = 2 * p1.y; y !== 2 * p2.y; y += yDir) {\r\n        const np3 = new geom.Offset(x, y + yDir);\r\n        // console.info(`- ${np3}`);\r\n        if (nextToLastMatch(newPoints, np3)) {\r\n            // This can happen around a corner, when just before the corner\r\n            // we dip into the corner\r\n            // console.info(` remove ${newPoints[newPoints.length - 1]}`);\r\n            mask.set(newPoints.splice(newPoints.length - 1, 1)[0], false);\r\n            continue;\r\n        }\r\n        if (i === points.length - 2 && mask.get(np3)) {\r\n            // This can happen if the first point was on a corner and the\r\n            // first move was to dip into the corner\r\n            const index = newPoints.findIndex((point) => point.equals(np3));\r\n            // console.info(`remove ${index} from beginning`);\r\n            for (const point of newPoints.splice(0, index)) {\r\n                mask.set(point, false);\r\n            }\r\n            addPoint(newPoints, mask, np3);\r\n            break;\r\n        }\r\n        if (random() < variation) {\r\n            const v = Math.floor(random() * 2) * 2 - 1;\r\n            const np1 = new geom.Offset(x + v, y);\r\n            const np2 = new geom.Offset(x + v, y + yDir);\r\n            if (!mask.get(np2)) {\r\n                if (!mask.get(np1) || nextToLastMatch(newPoints, np1)) {\r\n                    addPoint(newPoints, mask, np1);\r\n                    addPoint(newPoints, mask, np2);\r\n                }\r\n            }\r\n        }\r\n        addPoint(newPoints, mask, np3);\r\n    }\r\n}\r\n\r\nfunction horizontalHelper(points: geom.Offset[], random: () => number, variation: number,\r\n                          newPoints: geom.Offset[], mask: geom.MaskRect, i: number,\r\n                          p1: geom.Offset, p2: geom.Offset) {\r\n    const y = 2 * p1.y;\r\n    const xDir = p2.x - p1.x;\r\n    for (let x = 2 * p1.x; x !== 2 * p2.x; x += xDir) {\r\n        const np3 = new geom.Offset(x + xDir, y);\r\n        // console.info(`- ${np3}`);\r\n        if (nextToLastMatch(newPoints, np3)) {\r\n            // This can happen around a corner, when just before the corner\r\n            // we dip in the direction of the corner\r\n            // console.info(` remove ${newPoints[newPoints.length - 1]}`);\r\n            mask.set(newPoints.splice(newPoints.length - 1, 1)[0], false);\r\n            continue;\r\n        }\r\n        if (i === points.length - 2 && mask.get(np3)) {\r\n            // This can happen if the first point was on a corner and the\r\n            // first move was to dip into the corner\r\n            const index = newPoints.findIndex((point) => point.equals(np3));\r\n            // console.info(`remove ${index} from beginning`);\r\n            for (const point of newPoints.splice(0, index)) {\r\n                mask.set(point, false);\r\n            }\r\n            addPoint(newPoints, mask, np3);\r\n            break;\r\n        }\r\n        if (random() < variation) {\r\n            const v = Math.floor(random() * 2) * 2 - 1;\r\n            const np1 = new geom.Offset(x, y + v);\r\n            const np2 = new geom.Offset(x + xDir, y + v);\r\n            if (!mask.get(np2)) {\r\n                if (!mask.get(np1) || nextToLastMatch(newPoints, np1)) {\r\n                    addPoint(newPoints, mask, np1);\r\n                    addPoint(newPoints, mask, np2);\r\n                }\r\n            }\r\n        }\r\n        addPoint(newPoints, mask, np3);\r\n    }\r\n}\r\n\r\nfunction blockFractalIteration(random: () => number, points: geom.Offset[],\r\n                               bounds: geom.RectangleLike, variation: number) {\r\n    const newPoints = new Array<geom.Offset>();\r\n    const newBounds = new geom.Rectangle(\r\n        bounds.westX * 2 - 1,\r\n        bounds.northY * 2 - 1,\r\n        bounds.width * 2 + 2,\r\n        bounds.height * 2 + 2,\r\n    );\r\n    // console.info(` bounds ${newBounds}`);\r\n    const mask = new geom.MaskRect(newBounds);\r\n    for (let i = 0; i < points.length - 1; i ++) {\r\n        const p1 = points[i];\r\n        const p2 = points[i + 1];\r\n        if (i === 0) {\r\n            addPoint(newPoints, mask, new geom.Offset(p1.x * 2, p1.y * 2));\r\n        }\r\n        if (p1.x === p2.x) {\r\n            verticalHelper(points, random, variation, newPoints, mask, i, p1, p2);\r\n        } else {\r\n            horizontalHelper(points, random, variation, newPoints, mask, i, p1, p2);\r\n        }\r\n    }\r\n    return {\r\n        points: newPoints,\r\n        bounds: newBounds,\r\n    };\r\n}\r\n\r\nexport function makeBlockFractal(param: BlockFractalParam): geom.Path {\r\n    let {random, shape, variation} = param;\r\n    if (typeof random === 'undefined') {\r\n        random = Math.random;\r\n    }\r\n    if (typeof shape === 'undefined') {\r\n        shape = new geom.Path({x: -1, y: -1}, [\r\n            geom.Direction.EAST,\r\n            geom.Direction.EAST,\r\n            geom.Direction.SOUTH,\r\n            geom.Direction.SOUTH,\r\n            geom.Direction.WEST,\r\n            geom.Direction.WEST,\r\n            geom.Direction.NORTH,\r\n            geom.Direction.NORTH,\r\n        ]);\r\n    }\r\n    if (typeof variation === 'undefined') {\r\n        variation = 0.4;\r\n    }\r\n\r\n    let points = new Array<geom.Offset>();\r\n    let bounds = shape.getBounds();\r\n    shape.getOffsets((off) => {\r\n        points.push(new geom.Offset(off.x, off.y));\r\n    });\r\n\r\n    for (let iter = 0; iter < param.iterations; iter ++) {\r\n        // console.info(`iteration ${iter + 1}`);\r\n        ({points, bounds} = blockFractalIteration(random, points, bounds, variation));\r\n    }\r\n\r\n    const segments = new Array<geom.Direction>();\r\n    for (let i = 0; i < points.length - 1; i ++) {\r\n        const curPoint = points[i];\r\n        const nextPoint = points[i + 1];\r\n        if (nextPoint.y === curPoint.y - 1) {\r\n            segments.push(geom.Direction.NORTH);\r\n        } else if (nextPoint.x === curPoint.x + 1) {\r\n            segments.push(geom.Direction.EAST);\r\n        } else if (nextPoint.y === curPoint.y + 1) {\r\n            segments.push(geom.Direction.SOUTH);\r\n        } else if (nextPoint.x === curPoint.x - 1) {\r\n            segments.push(geom.Direction.WEST);\r\n        }\r\n    }\r\n\r\n    return new geom.Path(points[0], segments);\r\n}\r\n","/*\r\n *  WallyFOV\r\n *  github.com/sbj42/WallyFOV\r\n *  James Clark\r\n *  Licensed under the MIT license.\r\n */\r\n\r\nexport {makeBlockFractal} from './block-fractal';\r\nexport {Direction, DirectionFlags, Offset, Path, RasterMask} from './geom';\r\n"],"sourceRoot":""}
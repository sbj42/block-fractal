{"version":3,"sources":["webpack://BlockFractal/webpack/bootstrap","webpack://BlockFractal/./src/geom/index.ts","webpack://BlockFractal/./src/index.ts","webpack://BlockFractal/./src/block-fractal.ts","webpack://BlockFractal/./src/geom/direction.ts","webpack://BlockFractal/./src/geom/direction-flags.ts","webpack://BlockFractal/./src/geom/offset.ts","webpack://BlockFractal/./src/geom/size.ts","webpack://BlockFractal/./src/geom/rectangle.ts","webpack://BlockFractal/./src/geom/mask.ts","webpack://BlockFractal/./src/geom/mask-rect.ts","webpack://BlockFractal/./src/geom/raster-mask.ts","webpack://BlockFractal/./src/geom/path.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","makeBlockFractal","Direction","DirectionFlags","Offset","Path","RasterMask","nextToLastMatch","points","next","length","equals","addPoint","mask","set","splice","push","verticalHelper","random","variation","newPoints","p1","p2","x","yDir","y","np3","geom","index","findIndex","point","v","Math","floor","np1","np2","horizontalHelper","xDir","blockFractalIteration","bounds","Array","newBounds","Rectangle","westX","northY","width","height","MaskRect","param","shape","EAST","SOUTH","WEST","NORTH","getBounds","getOffsets","off","iter","iterations","segments","curPoint","nextPoint","DIRECTIONS","DIRECTIONS_STR","dir","flags","ret","X_FROM_DIRECTION","Y_FROM_DIRECTION","this","toString","other","max","abs","copyFrom","setFromDirection","add","addSize","size","addOffset","addDirection","addCardinalDirection","subtractOffset","multiply","factor","distanceChebyshev","magnitudeChebyshev","distanceManhattan","magnitudeManhattan","containsOffset","Size","LOCAL_OFF","northWest","empty","area","extendToInclude","dx","dy","containsRectangle","overlapsRectangle","southY","eastX","initialValue","_size","_bits","ceil","fill","getAt","arrayIndex","bitMask","setAt","Mask","rect","outsideValue","_rectangle","_mask","_outsideValue","lines","_lines","line","start","end","bandsAt","callback","sortedInsert","array","low","high","mid","map","segment","directionToString","join","getIsClosed","cursor","min","getArea","total","rasterize"],"mappings":"6BACE,IAAIA,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAI,EAAQL,GAAUM,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QA0Df,OArDAF,EAAoBQ,EAAIF,EAGxBN,EAAoBS,EAAIV,EAGxBC,EAAoBU,EAAI,SAASR,EAASS,EAAMC,GAC3CZ,EAAoBa,EAAEX,EAASS,IAClCG,OAAOC,eAAeb,EAASS,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEZ,EAAoBkB,EAAI,SAAShB,GACX,oBAAXiB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeb,EAASiB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,KAQvDrB,EAAoBsB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQrB,EAAoBqB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFA1B,EAAoBkB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOrB,EAAoBU,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRzB,EAAoB6B,EAAI,SAAS1B,GAChC,IAAIS,EAAST,GAAUA,EAAOqB,WAC7B,WAAwB,OAAOrB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBU,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRZ,EAAoBa,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG/B,EAAoBkC,EAAI,QAIjBlC,EAAoBA,EAAoBmC,EAAI,G,mYClFrD,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WACA,Y,8ECDA,WAAQ,kFAAAC,oBACR,WAAQ,2EAAAC,aAAW,gFAAAC,kBAAgB,wEAAAC,UAAQ,sEAAAC,QAAM,4EAAAC,e,wGCRjD,WASA,SAASC,EAAgBC,EAAuBC,GAC5C,OAAOD,EAAOE,OAAS,GAAKF,EAAOA,EAAOE,OAAS,GAAGC,OAAOF,GAGjE,SAASG,EAASJ,EAAuBK,EAAqBJ,GACtDF,EAAgBC,EAAQC,GACxBI,EAAKC,IAAIN,EAAOO,OAAOP,EAAOE,OAAS,EAAG,GAAG,IAAI,IAEjDF,EAAOQ,KAAKP,GACZI,EAAKC,IAAIL,GAAM,IAIvB,SAASQ,EAAeT,EAAuBU,EAAsBC,EAC7CC,EAA0BP,EAAqB5C,EAC/CoD,EAAiBC,GAGrC,IAFA,IAAMC,EAAI,EAAIF,EAAGE,EACXC,EAAOF,EAAGG,EAAIJ,EAAGI,E,WACdA,GACL,IAAMC,EAAM,IAAIC,EAAKvB,OAAOmB,EAAGE,EAAID,GAEnC,GAAIjB,EAAgBa,EAAWM,G,OAI3Bb,EAAKC,IAAIM,EAAUL,OAAOK,EAAUV,OAAS,EAAG,GAAG,IAAI,G,WAG3D,GAAIzC,IAAMuC,EAAOE,OAAS,GAAKG,EAAK/B,IAAI4C,GAAM,CAK1C,IAFA,IAAME,EAAQR,EAAUS,WAAU,SAACC,GAAU,OAAAA,EAAMnB,OAAOe,MAEtC,MAAAN,EAAUL,OAAO,EAAGa,GAApB,eAA4B,CAA3C,IAAME,EAAK,KACZjB,EAAKC,IAAIgB,GAAO,G,OAEpBlB,EAASQ,EAAWP,EAAMa,G,QAG9B,GAAIR,IAAWC,EAAW,CACtB,IAAMY,EAA+B,EAA3BC,KAAKC,MAAiB,EAAXf,KAAoB,EACnCgB,EAAM,IAAIP,EAAKvB,OAAOmB,EAAIQ,EAAGN,GAC7BU,EAAM,IAAIR,EAAKvB,OAAOmB,EAAIQ,EAAGN,EAAID,GAClCX,EAAK/B,IAAIqD,IACLtB,EAAK/B,IAAIoD,KAAQ3B,EAAgBa,EAAWc,KAC7CtB,EAASQ,EAAWP,EAAMqB,GAC1BtB,EAASQ,EAAWP,EAAMsB,IAItCvB,EAASQ,EAAWP,EAAMa,IAhCrBD,EAAI,EAAIJ,EAAGI,EAAGA,IAAM,EAAIH,EAAGG,EAAGA,GAAKD,EAAM,C,eAAzCC,G,OAoCb,SAASW,EAAiB5B,EAAuBU,EAAsBC,EAC7CC,EAA0BP,EAAqB5C,EAC/CoD,EAAiBC,GAGvC,IAFA,IAAMG,EAAI,EAAIJ,EAAGI,EACXY,EAAOf,EAAGC,EAAIF,EAAGE,E,WACdA,GACL,IAAMG,EAAM,IAAIC,EAAKvB,OAAOmB,EAAIc,EAAMZ,GAEtC,GAAIlB,EAAgBa,EAAWM,G,OAI3Bb,EAAKC,IAAIM,EAAUL,OAAOK,EAAUV,OAAS,EAAG,GAAG,IAAI,G,WAG3D,GAAIzC,IAAMuC,EAAOE,OAAS,GAAKG,EAAK/B,IAAI4C,GAAM,CAK1C,IAFA,IAAME,EAAQR,EAAUS,WAAU,SAACC,GAAU,OAAAA,EAAMnB,OAAOe,MAEtC,MAAAN,EAAUL,OAAO,EAAGa,GAApB,eAA4B,CAA3C,IAAME,EAAK,KACZjB,EAAKC,IAAIgB,GAAO,G,OAEpBlB,EAASQ,EAAWP,EAAMa,G,QAG9B,GAAIR,IAAWC,EAAW,CACtB,IAAMY,EAA+B,EAA3BC,KAAKC,MAAiB,EAAXf,KAAoB,EACnCgB,EAAM,IAAIP,EAAKvB,OAAOmB,EAAGE,EAAIM,GAC7BI,EAAM,IAAIR,EAAKvB,OAAOmB,EAAIc,EAAMZ,EAAIM,GACrClB,EAAK/B,IAAIqD,IACLtB,EAAK/B,IAAIoD,KAAQ3B,EAAgBa,EAAWc,KAC7CtB,EAASQ,EAAWP,EAAMqB,GAC1BtB,EAASQ,EAAWP,EAAMsB,IAItCvB,EAASQ,EAAWP,EAAMa,IAhCrBH,EAAI,EAAIF,EAAGE,EAAGA,IAAM,EAAID,EAAGC,EAAGA,GAAKc,EAAM,C,eAAzCd,G,OAoCb,SAASe,EAAsBpB,EAAsBV,EACtB+B,EAA4BpB,GAUvD,IATA,IAAMC,EAAY,IAAIoB,MAChBC,EAAY,IAAId,EAAKe,UACR,EAAfH,EAAOI,MAAY,EACH,EAAhBJ,EAAOK,OAAa,EACL,EAAfL,EAAOM,MAAY,EACH,EAAhBN,EAAOO,OAAa,GAGlBjC,EAAO,IAAIc,EAAKoB,SAASN,GACtBxE,EAAI,EAAGA,EAAIuC,EAAOE,OAAS,EAAGzC,IAAM,CACzC,IAAMoD,EAAKb,EAAOvC,GACZqD,EAAKd,EAAOvC,EAAI,GACZ,IAANA,GACA2C,EAASQ,EAAWP,EAAM,IAAIc,EAAKvB,OAAc,EAAPiB,EAAGE,EAAc,EAAPF,EAAGI,IAEvDJ,EAAGE,IAAMD,EAAGC,EACZN,EAAeT,EAAQU,EAAQC,EAAWC,EAAWP,EAAM5C,EAAGoD,EAAIC,GAElEc,EAAiB5B,EAAQU,EAAQC,EAAWC,EAAWP,EAAM5C,EAAGoD,EAAIC,GAG5E,MAAO,CACHd,OAAQY,EACRmB,OAAQE,GAIhB,4BAAiCO,G,MACxB9B,EAA4B8B,EAAK,OAAzBC,EAAoBD,EAAK,MAAlB7B,EAAa6B,EAAK,eAChB,IAAX9B,IACPA,EAASc,KAAKd,aAEG,IAAV+B,IACPA,EAAQ,IAAItB,EAAKtB,KAAK,CAACkB,GAAI,EAAGE,GAAI,GAAI,CAClCE,EAAKzB,UAAUgD,KACfvB,EAAKzB,UAAUgD,KACfvB,EAAKzB,UAAUiD,MACfxB,EAAKzB,UAAUiD,MACfxB,EAAKzB,UAAUkD,KACfzB,EAAKzB,UAAUkD,KACfzB,EAAKzB,UAAUmD,MACf1B,EAAKzB,UAAUmD,cAGE,IAAdlC,IACPA,EAAY,IAGhB,IAAIX,EAAS,IAAIgC,MACbD,EAASU,EAAMK,YACnBL,EAAMM,YAAW,SAACC,GACdhD,EAAOQ,KAAK,IAAIW,EAAKvB,OAAOoD,EAAIjC,EAAGiC,EAAI/B,OAG3C,IAAK,IAAIgC,EAAO,EAAGA,EAAOT,EAAMU,WAAYD,IAEvC,EAAmBnB,EAAsBpB,EAAQV,EAAQ+B,EAAQpB,GAAhEX,EAAM,SAAE+B,EAAM,SAIpB,IADA,IAAMoB,EAAW,IAAInB,MACZvE,EAAI,EAAGA,EAAIuC,EAAOE,OAAS,EAAGzC,IAAM,CACzC,IAAM2F,EAAWpD,EAAOvC,GAClB4F,EAAYrD,EAAOvC,EAAI,GACzB4F,EAAUpC,IAAMmC,EAASnC,EAAI,EAC7BkC,EAAS3C,KAAKW,EAAKzB,UAAUmD,OACtBQ,EAAUtC,IAAMqC,EAASrC,EAAI,EACpCoC,EAAS3C,KAAKW,EAAKzB,UAAUgD,MACtBW,EAAUpC,IAAMmC,EAASnC,EAAI,EACpCkC,EAAS3C,KAAKW,EAAKzB,UAAUiD,OACtBU,EAAUtC,IAAMqC,EAASrC,EAAI,GACpCoC,EAAS3C,KAAKW,EAAKzB,UAAUkD,MAIrC,OAAO,IAAIzB,EAAKtB,KAAKG,EAAO,GAAImD,K,6BClLpC,IAAYzD,E,yHAAZ,SAAYA,GACR,qBACA,mBACA,qBACA,mBAJJ,CAAYA,EAAA,EAAAA,YAAA,EAAAA,UAAS,KAOR,EAAA4D,WAAa,CACtB5D,EAAUmD,MACVnD,EAAUgD,KACVhD,EAAUiD,MACVjD,EAAUkD,MAGd,IAAMW,EAAiB,CACnB,IACA,IACA,IACA,KAGJ,6BAAkCC,GAC9B,OAAOD,EAAeC,IAG1B,6BAAkCA,GAC9B,OAASA,EAAM,EAAK,I,6BCxBxB,IAAY7D,E,gIAAZ,SAAYA,GACR,mBACA,qBACA,mBACA,qBACA,mBACA,kBANJ,CAAYA,EAAA,EAAAA,iBAAA,EAAAA,eAAc,KAS1B,kCAAuC8D,GACnC,IAAIC,EAAM,IAaV,OAZuC,IAAlCD,EAAQ9D,EAAekD,SACxBa,GAAO,KAE2B,IAAjCD,EAAQ9D,EAAe+C,QACxBgB,GAAO,KAE4B,IAAlCD,EAAQ9D,EAAegD,SACxBe,GAAO,KAE2B,IAAjCD,EAAQ9D,EAAeiD,QACxBc,GAAO,KAEJA,EAAM,KAKjB,uCAA4CF,GACxC,OAAQ,GAAKA,I,8FC/BjB,IAAMG,EAAmB,CAAG,EAAG,EAAG,GAAI,GAChCC,EAAmB,EAAG,EAAG,EAAG,EAAI,GAOtC,aAMI,WAAY7C,EAAYE,QACH,IAANF,IACPA,EAAI,QAES,IAANE,IACPA,EAAI,GAER4C,KAAK9C,EAAIA,EACT8C,KAAK5C,EAAIA,EAgGjB,OA3FI,YAAA6C,SAAA,WACI,MAAO,IAAID,KAAK9C,EAAC,IAAI8C,KAAK5C,EAAC,KAG/B,YAAAd,OAAA,SAAO4D,GACH,OAAOF,KAAK9C,IAAMgD,EAAMhD,GAAK8C,KAAK5C,IAAM8C,EAAM9C,GAIlD,sBAAI,iCAAkB,C,IAAtB,WACI,OAAOO,KAAKwC,IAAIxC,KAAKyC,IAAIJ,KAAK9C,GAAIS,KAAKyC,IAAIJ,KAAK5C,K,gCAIpD,sBAAI,iCAAkB,C,IAAtB,WACI,OAAOO,KAAKyC,IAAIJ,KAAK9C,GAAKS,KAAKyC,IAAIJ,KAAK5C,I,gCAK5C,YAAAX,IAAA,SAAIS,EAAWE,GAGX,OAFA4C,KAAK9C,EAAIA,EACT8C,KAAK5C,EAAIA,EACF4C,MAGX,YAAAK,SAAA,SAASH,GAGL,OAFAF,KAAK9C,EAAIgD,EAAMhD,EACf8C,KAAK5C,EAAI8C,EAAM9C,EACR4C,MAGX,YAAAM,iBAAA,SAAiBX,GAGb,OAFAK,KAAK9C,EAAI4C,EAAiBH,GAC1BK,KAAK5C,EAAI2C,EAAiBJ,GACnBK,MAGX,YAAAO,IAAA,SAAIrD,EAAWE,GAGX,OAFA4C,KAAK9C,GAAKA,EACV8C,KAAK5C,GAAKA,EACH4C,MAGX,YAAAQ,QAAA,SAAQC,GAGJ,OAFAT,KAAK9C,GAAKuD,EAAKjC,MACfwB,KAAK5C,GAAKqD,EAAKhC,OACRuB,MAGX,YAAAU,UAAA,SAAUvB,GAGN,OAFAa,KAAK9C,GAAKiC,EAAIjC,EACd8C,KAAK5C,GAAK+B,EAAI/B,EACP4C,MAGX,YAAAW,aAAA,SAAahB,GAGT,OAFAK,KAAK9C,GAAK4C,EAAiBH,GAC3BK,KAAK5C,GAAK2C,EAAiBJ,GACpBK,MAGX,YAAAY,qBAAA,SAAqBjB,GAGjB,OAFAK,KAAK9C,GAAK4C,EAAiBH,GAC3BK,KAAK5C,GAAK2C,EAAiBJ,GACpBK,MAGX,YAAAa,eAAA,SAAe1B,GAGX,OAFAa,KAAK9C,GAAKiC,EAAIjC,EACd8C,KAAK5C,GAAK+B,EAAI/B,EACP4C,MAGX,YAAAc,SAAA,SAASC,GAGL,OAFAf,KAAK9C,GAAK6D,EACVf,KAAK5C,GAAK2D,EACHf,MAMX,YAAAgB,kBAAA,SAAkBd,GACd,OAAOF,KAAKa,eAAeX,GAAOe,oBAItC,YAAAC,kBAAA,SAAkBhB,GACd,OAAOF,KAAKa,eAAeX,GAAOiB,oBAE1C,EA9GA,GAAa,EAAApF,U,4FCHb,iBAMI,WAAYyC,EAAgBC,QACH,IAAVD,IACPA,EAAQ,QAEU,IAAXC,IACPA,EAAS,GAEbuB,KAAKxB,MAAQA,EACbwB,KAAKvB,OAASA,EAgEtB,OA3DI,YAAAwB,SAAA,WACI,MAAO,IAAID,KAAKxB,MAAK,IAAIwB,KAAKvB,OAAM,KAGxC,YAAAnC,OAAA,SAAO4D,GACH,OAAOF,KAAKxB,QAAU0B,EAAM1B,OAASwB,KAAKvB,SAAWyB,EAAMzB,QAG/D,sBAAI,oBAAK,C,IAAT,WACI,OAAsB,IAAfuB,KAAKxB,OAA+B,IAAhBwB,KAAKvB,Q,gCAGpC,sBAAI,mBAAI,C,IAAR,WACI,OAAOuB,KAAKxB,MAAQwB,KAAKvB,Q,gCAK7B,YAAAhC,IAAA,SAAI+B,EAAeC,GAGf,OAFAuB,KAAKxB,MAAQA,EACbwB,KAAKvB,OAASA,EACPuB,MAGX,YAAAK,SAAA,SAASH,GAGL,OAFAF,KAAKxB,MAAQ0B,EAAM1B,MACnBwB,KAAKvB,OAASyB,EAAMzB,OACbuB,MAGX,YAAAO,IAAA,SAAI/B,EAAeC,GAGf,OAFAuB,KAAKxB,OAASA,EACdwB,KAAKvB,QAAUA,EACRuB,MAGX,YAAAU,UAAA,SAAUvB,GAGN,OAFAa,KAAKxB,OAASW,EAAIjC,EAClB8C,KAAKvB,QAAUU,EAAI/B,EACZ4C,MAGX,YAAAc,SAAA,SAASC,GAGL,OAFAf,KAAKxB,OAASuC,EACdf,KAAKvB,QAAUsC,EACRf,MAOX,YAAAoB,eAAA,SAAejC,GACX,OAAOA,EAAIjC,GAAK,GAAKiC,EAAI/B,GAAK,GAAK+B,EAAIjC,EAAI8C,KAAKxB,OAASW,EAAI/B,EAAI4C,KAAKvB,QAG1E,YAAAlB,MAAA,SAAM4B,GACF,OAAOA,EAAI/B,EAAI4C,KAAKxB,MAAQW,EAAIjC,GAExC,EA9EA,GAAa,EAAAmE,Q,iGCPb,WAOMC,EAAY,IAAIhE,EAAKvB,OAE3B,aAMI,WAAYuC,EAAgBC,EAAiBC,EAAgBC,QACpC,IAAVH,IACPA,EAAQ,QAEU,IAAXC,IACPA,EAAS,QAEQ,IAAVC,IACPA,EAAQ,QAEU,IAAXC,IACPA,EAAS,GAEbuB,KAAKuB,UAAY,IAAIjE,EAAKvB,OAAOuC,EAAOC,GACxCyB,KAAKS,KAAO,IAAInD,EAAK+D,KAAK7C,EAAOC,GA0GzC,OArGI,YAAAwB,SAAA,WACI,MAAO,IAAID,KAAK1B,MAAK,IAAI0B,KAAKzB,OAAM,IAAIyB,KAAKxB,MAAK,IAAIwB,KAAKvB,OAAM,KAGrE,YAAAnC,OAAA,SAAO4D,GACH,OAAOF,KAAK1B,QAAU4B,EAAM5B,OAAS0B,KAAKzB,SAAW2B,EAAM3B,QAAUyB,KAAKS,KAAKnE,OAAO4D,IAG1F,sBAAI,qBAAM,C,IAAV,WACI,OAAOF,KAAKuB,UAAUnE,G,gCAG1B,sBAAI,qBAAM,C,IAAV,WACI,OAAO4C,KAAKuB,UAAUnE,EAAI4C,KAAKS,KAAKhC,OAAS,G,gCAGjD,sBAAI,oBAAK,C,IAAT,WACI,OAAOuB,KAAKuB,UAAUrE,G,gCAG1B,sBAAI,oBAAK,C,IAAT,WACI,OAAO8C,KAAKuB,UAAUrE,EAAI8C,KAAKS,KAAKjC,MAAQ,G,gCAGhD,sBAAI,oBAAK,C,IAAT,WACI,OAAOwB,KAAKS,KAAKjC,O,gCAGrB,sBAAI,qBAAM,C,IAAV,WACI,OAAOwB,KAAKS,KAAKhC,Q,gCAGrB,sBAAI,oBAAK,C,IAAT,WACI,OAAOuB,KAAKS,KAAKe,O,gCAGrB,sBAAI,mBAAI,C,IAAR,WACI,OAAOxB,KAAKS,KAAKgB,M,gCAKrB,YAAAhF,IAAA,SAAI6B,EAAeC,EAAgBC,EAAeC,GAG9C,OAFAuB,KAAKuB,UAAU9E,IAAI6B,EAAOC,GAC1ByB,KAAKS,KAAKhE,IAAI+B,EAAOC,GACduB,MAGX,YAAAK,SAAA,SAASH,GAGL,OAFAF,KAAKuB,UAAU9E,IAAIyD,EAAM5B,MAAO4B,EAAM3B,QACtCyB,KAAKS,KAAKhE,IAAIyD,EAAM1B,MAAO0B,EAAMzB,QAC1BuB,MAGX,YAAA0B,gBAAA,SAAgBvC,GACZ,IAAMwC,EAAKxC,EAAIjC,EAAI8C,KAAK1B,MACpBqD,EAAK,GACL3B,KAAKS,KAAKjC,OAASmD,EACnB3B,KAAKuB,UAAUrE,EAAIiC,EAAIjC,GAChByE,GAAM3B,KAAKS,KAAKjC,QACvBwB,KAAKS,KAAKjC,MAAQmD,EAAK,GAE3B,IAAMC,EAAKzC,EAAI/B,EAAI4C,KAAKuB,UAAUnE,EAOlC,OANIwE,EAAK,GACL5B,KAAKS,KAAKhC,QAAUmD,EACpB5B,KAAKuB,UAAUnE,EAAI+B,EAAI/B,GAChBwE,GAAM5B,KAAKS,KAAKhC,SACvBuB,KAAKS,KAAKhC,OAASmD,EAAK,GAErB5B,MAKX,YAAAoB,eAAA,SAAejC,GACX,OAAOa,KAAKS,KAAKW,eAAeE,EAAUjB,SAASlB,GAAK0B,eAAeb,KAAKuB,aAGhF,YAAAM,kBAAA,SAAkB3B,GAEd,OADAoB,EAAU7E,IAAIyD,EAAM5B,MAAO4B,EAAM3B,QAAQsC,eAAeb,KAAKuB,aACxDvB,KAAKS,KAAKW,eAAeE,MAGV,IAAhBpB,EAAM1B,OAAgC,IAAjB0B,EAAMzB,SAGxBuB,KAAKS,KAAKW,eAAeE,EAAUf,IAAIL,EAAM1B,MAAQ,EAAG0B,EAAMzB,OAAS,MAGlF,YAAAqD,kBAAA,SAAkB5B,GACd,OAAOF,KAAKzB,QAAU2B,EAAM3B,OAAS2B,EAAMzB,OAAS,GAC7CuB,KAAK+B,QAAU7B,EAAM3B,QACrByB,KAAK1B,OAAS4B,EAAM5B,MAAQ4B,EAAM1B,MAAQ,GAC1CwB,KAAKgC,OAAS9B,EAAM5B,QACnB0B,KAAKwB,OACU,IAAhBtB,EAAM1B,OAAgC,IAAjB0B,EAAMzB,QAGtC,YAAAlB,MAAA,SAAM4B,GACF,OAAOa,KAAKS,KAAKlD,MAAM+D,EAAUjB,SAASlB,GAAK0B,eAAeb,KAAKuB,aAE3E,EA9HA,GAAa,EAAAlD,a,4FCTb,WAEA,aAKI,WAAYoC,EAAqBwB,QAAA,IAAAA,OAAA,GAJhB,KAAAC,MAAQ,IAAI5E,EAAK+D,KAK9BrB,KAAKkC,MAAM7B,SAASI,GACpBT,KAAKmC,MAAQ,IAAIhE,MAAcR,KAAKyE,KAAKpC,KAAKkC,MAAMT,KAAO,KAAKY,KAAKJ,EAAe,WAAa,GA4DzG,OAvDI,YAAAhC,SAAA,WAGI,IAFA,IAAIJ,EAAM,GACJV,EAAM,IAAI7B,EAAKvB,OACZqB,EAAI,EAAGA,EAAI4C,KAAKkC,MAAMzD,OAAQrB,IAAM,CACzC,IAAK,IAAIF,EAAI,EAAGA,EAAI8C,KAAKkC,MAAM1D,MAAOtB,IAClCiC,EAAI1C,IAAIS,EAAGE,GACXyC,GAAOG,KAAKvF,IAAI0E,EAAI1C,IAAIS,EAAGE,IAAM,IAAM,IAE3CyC,GAAO,KAEX,OAAOA,GAGX,sBAAI,oBAAK,C,IAAT,WACI,OAAOG,KAAKkC,MAAM1D,O,gCAGtB,sBAAI,qBAAM,C,IAAV,WACI,OAAOwB,KAAKkC,MAAMzD,Q,gCAGtB,YAAAlB,MAAA,SAAM4B,GACF,OAAOa,KAAKkC,MAAM3E,MAAM4B,IAG5B,YAAAmD,MAAA,SAAM/E,GAEF,IAAMgF,EAAahF,IAAU,EACvBiF,EAAU,IAAc,GAARjF,GACtB,OAA8C,IAAtCyC,KAAKmC,MAAMI,GAAcC,IAIrC,YAAA/H,IAAA,SAAI0E,GACA,OAAOa,KAAKsC,MAAMtC,KAAKzC,MAAM4B,KAKjC,YAAAsD,MAAA,SAAMlF,EAAe1C,GAEjB,IAAM0H,EAAahF,IAAU,EACvBiF,EAAU,IAAc,GAARjF,GAOtB,OANI1C,EACAmF,KAAKmC,MAAMI,IAAeC,EAE1BxC,KAAKmC,MAAMI,KAAgBC,EAGxBxC,MAGX,YAAAvD,IAAA,SAAI0C,EAAsBtE,GACtB,OAAOmF,KAAKyC,MAAMzC,KAAKzC,MAAM4B,GAAMtE,IAE3C,EAnEA,GAAa,EAAA6H,Q,gGCFb,WAEMpB,EAAY,IAAIhE,EAAKvB,OAE3B,aAKI,WAAY4G,EAA0BV,EAAsBW,QAAtB,IAAAX,OAAA,QAAsB,IAAAW,OAAA,GAJ3C,KAAAC,WAAa,IAAIvF,EAAKe,UAKnC2B,KAAK6C,WAAWxC,SAASsC,GACzB3C,KAAK8C,MAAQ,IAAIxF,EAAKoF,KAAKC,EAAMV,GACjCjC,KAAK+C,cAAgBH,EAmD7B,OA9CI,YAAA3C,SAAA,WACI,OAAUD,KAAK6C,WAAWtB,UAAS,IAAIvB,KAAK+C,cAAa,KAAK/C,KAAK8C,OAGvE,sBAAI,oBAAK,C,IAAT,WACI,OAAO9C,KAAK6C,WAAWvE,O,gCAG3B,sBAAI,qBAAM,C,IAAV,WACI,OAAO0B,KAAK6C,WAAWtE,Q,gCAG3B,sBAAI,oBAAK,C,IAAT,WACI,OAAOyB,KAAK6C,WAAWrE,O,gCAG3B,sBAAI,qBAAM,C,IAAV,WACI,OAAOwB,KAAK6C,WAAWpE,Q,gCAG3B,YAAAlB,MAAA,SAAM4B,GACF,OAAOa,KAAK8C,MAAMvF,MAAM+D,EAAUjB,SAASlB,GAAK0B,eAAeb,KAAK6C,WAAWtB,aAGnF,YAAAe,MAAA,SAAM/E,GACF,OAAOyC,KAAK8C,MAAMR,MAAM/E,IAG5B,YAAA9C,IAAA,SAAI0E,GACA,OAAKa,KAAK6C,WAAWzB,eAAejC,GAG7Ba,KAAK8C,MAAMR,MAAMtC,KAAK6C,WAAWtF,MAAM4B,IAFnCa,KAAK+C,eAOpB,YAAAN,MAAA,SAAMlF,EAAe1C,GAEjB,OADAmF,KAAK8C,MAAML,MAAMlF,EAAO1C,GACjBmF,MAGX,YAAAvD,IAAA,SAAI0C,EAAsBtE,GAEtB,OADAmF,KAAK8C,MAAML,MAAMzC,KAAK6C,WAAWtF,MAAM4B,GAAMtE,GACtCmF,MAEf,EA3DA,GAAa,EAAAtB,Y,kGCJb,WAEA,aAKI,WAAYR,EAA4B8E,GACpChD,KAAKuB,UAAY,IAAIjE,EAAKvB,OAAOmC,EAAOI,MAAOJ,EAAOK,QACtDyB,KAAKS,KAAO,IAAInD,EAAK+D,KAAKnD,EAAOM,MAAON,EAAOO,QAC/CuB,KAAKiD,OAASD,EA6EtB,OA1EI,YAAA/C,SAAA,WAEI,IADA,IAAIrB,EAAQ,GACHxB,EAAI,EAAGA,EAAI4C,KAAKvB,OAAQrB,IAAM,CAGnC,IAFA,IAAM8F,EAAOlD,KAAKiD,OAAO7F,GACrBF,EAAI8C,KAAK1B,MACJ1E,EAAI,EAAGA,EAAIsJ,EAAK7G,OAAQzC,GAAK,EAAG,CAGrC,IAFA,IAAMuJ,EAAQD,EAAKtJ,GACbwJ,EAAMF,EAAKtJ,EAAI,GACdsD,EAAIiG,GACPvE,GAAS,IACT1B,IAEJ,KAAOA,EAAIkG,GACPxE,GAAS,IACT1B,IAGR,KAAOA,GAAK8C,KAAKgC,OACbpD,GAAS,IACT1B,IAEJ0B,GAAS,KAEb,OAAUoB,KAAKuB,UAAS,KAAK3C,GAKjC,sBAAI,qBAAM,C,IAAV,WACI,OAAOoB,KAAKuB,UAAUnE,G,gCAG1B,sBAAI,qBAAM,C,IAAV,WACI,OAAO4C,KAAKuB,UAAUnE,EAAI4C,KAAKS,KAAKhC,OAAS,G,gCAGjD,sBAAI,oBAAK,C,IAAT,WACI,OAAOuB,KAAKuB,UAAUrE,G,gCAG1B,sBAAI,oBAAK,C,IAAT,WACI,OAAO8C,KAAKuB,UAAUrE,EAAI8C,KAAKS,KAAKjC,MAAQ,G,gCAGhD,sBAAI,oBAAK,C,IAAT,WACI,OAAOwB,KAAKS,KAAKjC,O,gCAGrB,sBAAI,qBAAM,C,IAAV,WACI,OAAOwB,KAAKS,KAAKhC,Q,gCAGrB,YAAAhE,IAAA,SAAIyC,EAAWE,GACX,GAAIA,EAAI4C,KAAKzB,QAAUnB,EAAI4C,KAAK+B,OAC5B,OAAO,EAGX,IADA,IAAMmB,EAAOlD,KAAKiD,OAAO7F,EAAI4C,KAAKzB,QACzB3E,EAAI,EAAGA,EAAIsJ,EAAK7G,OAAQzC,GAAK,EAClC,GAAIsD,GAAKgG,EAAKtJ,IAAMsD,EAAIgG,EAAKtJ,EAAI,GAC7B,OAAO,EAGf,OAAO,GAGX,YAAAyJ,QAAA,SAAQjG,EAAWkG,GACf,KAAIlG,EAAI4C,KAAKzB,QAAUnB,EAAI4C,KAAK+B,QAIhC,IADA,IAAMmB,EAAOlD,KAAKiD,OAAO7F,EAAI4C,KAAKzB,QACzB3E,EAAI,EAAGA,EAAIsJ,EAAK7G,OAAQzC,GAAK,EAClC0J,EAASJ,EAAKtJ,GAAIsJ,EAAKtJ,EAAI,GAAK,IAG5C,EArFA,GAAa,EAAAqC,c,4FCFb,WAEMqF,EAAY,IAAIhE,EAAKvB,OAE3B,SAASwH,EAAaC,EAAiB3I,GAInC,IAHA,IAAI4I,EAAM,EACNC,EAAOF,EAAMnH,OAEVoH,EAAMC,GAAM,CAEf,IAAMC,EAAOF,EAAMC,IAAU,EACzBF,EAAMG,GAAO9I,EACb4I,EAAME,EAAM,EAEZD,EAAOC,EAIfH,EAAM9G,OAAO+G,EAAK,EAAG5I,GAGzB,iBAMI,WAAYsI,EAAyB7D,GACjCU,KAAKmD,MAAQ,IAAI7F,EAAKvB,YACD,IAAVoH,GACPnD,KAAKmD,MAAM9C,SAAS8C,QAEA,IAAb7D,IACPA,EAAW,IAAInB,OAEnB6B,KAAKV,SAAWA,EAiGxB,OA9FI,YAAAW,SAAA,WACI,OAAUD,KAAKmD,MAAMlD,WAAU,IACtBD,KAAKV,SAASsE,KAAI,SAACC,GAAY,OAAAvG,EAAKwG,kBAAkBD,MAAUE,KAAK,KAGlF,YAAAC,YAAA,WACI1C,EAAUjB,SAASL,KAAKmD,OACxB,IAAsB,UAAAnD,KAAKV,SAAL,eAAe,CAAhC,IAAMuE,EAAO,KACdvC,EAAUX,aAAakD,GAE3B,OAAO7D,KAAKmD,MAAM7G,OAAOgF,IAG7B,YAAApC,WAAA,SAAWoE,GACP,IAAMW,EAAS,IAAI3G,EAAKvB,OACxBkI,EAAO5D,SAASL,KAAKmD,OACrBG,EAASW,GACT,IAAsB,UAAAjE,KAAKV,SAAL,eAAe,CAAhC,IAAMuE,EAAO,KACdI,EAAOtD,aAAakD,GACpBP,EAASW,KAIjB,YAAAhF,UAAA,WACI,IAAIV,EAASyB,KAAKmD,MAAM/F,EACpB2E,EAASxD,EACTD,EAAQ0B,KAAKmD,MAAMjG,EACnB8E,EAAQ1D,EACZgD,EAAUjB,SAASL,KAAKmD,OACxB,IAAsB,UAAAnD,KAAKV,SAAL,eAAe,CAAhC,IAAMuE,EAAO,KAEd,OADAvC,EAAUX,aAAakD,GACfA,GACR,KAAKvG,EAAKzB,UAAUmD,MAChBT,EAASZ,KAAKuG,IAAI3F,EAAQ+C,EAAUlE,GACpC,MACJ,KAAKE,EAAKzB,UAAUgD,KAChBmD,EAAQrE,KAAKwC,IAAI6B,EAAOV,EAAUpE,GAClC,MACJ,KAAKI,EAAKzB,UAAUiD,MAChBiD,EAASpE,KAAKwC,IAAI4B,EAAQT,EAAUlE,GACpC,MACJ,KAAKE,EAAKzB,UAAUkD,KAChBT,EAAQX,KAAKuG,IAAI5F,EAAOgD,EAAUpE,IAI1C,OAAO,IAAII,EAAKe,UAAUC,EAAOC,EAAQyD,EAAQ1D,EAAQ,EAAGyD,EAASxD,EAAS,IAGlF,YAAA4F,QAAA,WACI,IAAIC,EAAQ,EACZ9C,EAAUjB,SAASL,KAAKmD,OACxB,IAAsB,UAAAnD,KAAKV,SAAL,eAAe,CAAhC,IAAMuE,EAAO,KAEd,OADAvC,EAAUX,aAAakD,GACfA,GACR,KAAKvG,EAAKzB,UAAUmD,MAChBoF,GAAS9C,EAAUpE,EACnB,MACJ,KAAKI,EAAKzB,UAAUiD,MAChBsF,GAAS9C,EAAUpE,GAI3B,OAAOS,KAAKyC,IAAIgE,IAGpB,YAAAC,UAAA,SAAUnG,GACN,IAAM8E,EAAQ,IAAI7E,WACI,IAAXD,IACPA,EAAS8B,KAAKf,aAElBqC,EAAUjB,SAASL,KAAKmD,OAGxB,IAFO,IAAA5E,EAAUL,EAAM,OACjB6D,EAASxD,EAASL,EAAOO,OAAS,EAC/BrB,EAAImB,EAAQnB,EAAI2E,EAAQ3E,IAC7B4F,EAAMrG,KAAK,IAEf2E,EAAUjB,SAASL,KAAKmD,OACxB,IAAsB,UAAAnD,KAAKV,SAAL,eAAe,CAAhC,IAAMuE,EAAO,KACVA,IAAYvG,EAAKzB,UAAUiD,OAC3ByE,EAAaP,EAAM1B,EAAUlE,EAAImB,GAAS+C,EAAUpE,GAExDoE,EAAUX,aAAakD,GACnBA,IAAYvG,EAAKzB,UAAUmD,OAC3BuE,EAAaP,EAAM1B,EAAUlE,EAAImB,GAAS+C,EAAUpE,GAG5D,OAAO,IAAII,EAAKrB,WAAW,CACvBqC,MAAOJ,EAAOI,MACdC,OAAQL,EAAOK,OACfC,MAAON,EAAOM,MAAQ,EACtBC,OAAQP,EAAOO,OAAS,GACzBuE,IAEX,EA/GA,GAAa,EAAAhH","file":"block-fractal-1.0.3.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/bin/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","export * from './direction';\r\nexport * from './direction-flags';\r\nexport * from './offset';\r\nexport * from './size';\r\nexport * from './rectangle';\r\nexport * from './mask';\r\nexport * from './mask-rect';\r\nexport * from './raster-mask';\r\nexport * from './path';\r\n","/*\r\n *  WallyFOV\r\n *  github.com/sbj42/WallyFOV\r\n *  James Clark\r\n *  Licensed under the MIT license.\r\n */\r\n\r\nexport {makeBlockFractal} from './block-fractal';\r\nexport {Direction, DirectionFlags, Offset, Path, RasterMask} from './geom';\r\n","import * as geom from './geom';\r\n\r\nexport interface BlockFractalParam {\r\n    random?: () => number;\r\n    iterations: number;\r\n    shape?: geom.Path;\r\n    variation?: number;\r\n}\r\n\r\nfunction nextToLastMatch(points: geom.Offset[], next: geom.Offset) {\r\n    return points.length > 1 && points[points.length - 2].equals(next);\r\n}\r\n\r\nfunction addPoint(points: geom.Offset[], mask: geom.MaskRect, next: geom.Offset) {\r\n    if (nextToLastMatch(points, next)) {\r\n        mask.set(points.splice(points.length - 1, 1)[0], false);\r\n    } else {\r\n        points.push(next);\r\n        mask.set(next, true);\r\n    }\r\n}\r\n\r\nfunction verticalHelper(points: geom.Offset[], random: () => number, variation: number,\r\n                        newPoints: geom.Offset[], mask: geom.MaskRect, i: number,\r\n                        p1: geom.Offset, p2: geom.Offset) {\r\n    const x = 2 * p1.x;\r\n    const yDir = p2.y - p1.y;\r\n    for (let y = 2 * p1.y; y !== 2 * p2.y; y += yDir) {\r\n        const np3 = new geom.Offset(x, y + yDir);\r\n        // console.info(`- ${np3}`);\r\n        if (nextToLastMatch(newPoints, np3)) {\r\n            // This can happen around a corner, when just before the corner\r\n            // we dip into the corner\r\n            // console.info(` remove ${newPoints[newPoints.length - 1]}`);\r\n            mask.set(newPoints.splice(newPoints.length - 1, 1)[0], false);\r\n            continue;\r\n        }\r\n        if (i === points.length - 2 && mask.get(np3)) {\r\n            // This can happen if the first point was on a corner and the\r\n            // first move was to dip into the corner\r\n            const index = newPoints.findIndex((point) => point.equals(np3));\r\n            // console.info(`remove ${index} from beginning`);\r\n            for (const point of newPoints.splice(0, index)) {\r\n                mask.set(point, false);\r\n            }\r\n            addPoint(newPoints, mask, np3);\r\n            break;\r\n        }\r\n        if (random() < variation) {\r\n            const v = Math.floor(random() * 2) * 2 - 1;\r\n            const np1 = new geom.Offset(x + v, y);\r\n            const np2 = new geom.Offset(x + v, y + yDir);\r\n            if (!mask.get(np2)) {\r\n                if (!mask.get(np1) || nextToLastMatch(newPoints, np1)) {\r\n                    addPoint(newPoints, mask, np1);\r\n                    addPoint(newPoints, mask, np2);\r\n                }\r\n            }\r\n        }\r\n        addPoint(newPoints, mask, np3);\r\n    }\r\n}\r\n\r\nfunction horizontalHelper(points: geom.Offset[], random: () => number, variation: number,\r\n                          newPoints: geom.Offset[], mask: geom.MaskRect, i: number,\r\n                          p1: geom.Offset, p2: geom.Offset) {\r\n    const y = 2 * p1.y;\r\n    const xDir = p2.x - p1.x;\r\n    for (let x = 2 * p1.x; x !== 2 * p2.x; x += xDir) {\r\n        const np3 = new geom.Offset(x + xDir, y);\r\n        // console.info(`- ${np3}`);\r\n        if (nextToLastMatch(newPoints, np3)) {\r\n            // This can happen around a corner, when just before the corner\r\n            // we dip in the direction of the corner\r\n            // console.info(` remove ${newPoints[newPoints.length - 1]}`);\r\n            mask.set(newPoints.splice(newPoints.length - 1, 1)[0], false);\r\n            continue;\r\n        }\r\n        if (i === points.length - 2 && mask.get(np3)) {\r\n            // This can happen if the first point was on a corner and the\r\n            // first move was to dip into the corner\r\n            const index = newPoints.findIndex((point) => point.equals(np3));\r\n            // console.info(`remove ${index} from beginning`);\r\n            for (const point of newPoints.splice(0, index)) {\r\n                mask.set(point, false);\r\n            }\r\n            addPoint(newPoints, mask, np3);\r\n            break;\r\n        }\r\n        if (random() < variation) {\r\n            const v = Math.floor(random() * 2) * 2 - 1;\r\n            const np1 = new geom.Offset(x, y + v);\r\n            const np2 = new geom.Offset(x + xDir, y + v);\r\n            if (!mask.get(np2)) {\r\n                if (!mask.get(np1) || nextToLastMatch(newPoints, np1)) {\r\n                    addPoint(newPoints, mask, np1);\r\n                    addPoint(newPoints, mask, np2);\r\n                }\r\n            }\r\n        }\r\n        addPoint(newPoints, mask, np3);\r\n    }\r\n}\r\n\r\nfunction blockFractalIteration(random: () => number, points: geom.Offset[],\r\n                               bounds: geom.RectangleLike, variation: number) {\r\n    const newPoints = new Array<geom.Offset>();\r\n    const newBounds = new geom.Rectangle(\r\n        bounds.westX * 2 - 1,\r\n        bounds.northY * 2 - 1,\r\n        bounds.width * 2 + 2,\r\n        bounds.height * 2 + 2,\r\n    );\r\n    // console.info(` bounds ${newBounds}`);\r\n    const mask = new geom.MaskRect(newBounds);\r\n    for (let i = 0; i < points.length - 1; i ++) {\r\n        const p1 = points[i];\r\n        const p2 = points[i + 1];\r\n        if (i === 0) {\r\n            addPoint(newPoints, mask, new geom.Offset(p1.x * 2, p1.y * 2));\r\n        }\r\n        if (p1.x === p2.x) {\r\n            verticalHelper(points, random, variation, newPoints, mask, i, p1, p2);\r\n        } else {\r\n            horizontalHelper(points, random, variation, newPoints, mask, i, p1, p2);\r\n        }\r\n    }\r\n    return {\r\n        points: newPoints,\r\n        bounds: newBounds,\r\n    };\r\n}\r\n\r\nexport function makeBlockFractal(param: BlockFractalParam): geom.Path {\r\n    let {random, shape, variation} = param;\r\n    if (typeof random === 'undefined') {\r\n        random = Math.random;\r\n    }\r\n    if (typeof shape === 'undefined') {\r\n        shape = new geom.Path({x: -1, y: -1}, [\r\n            geom.Direction.EAST,\r\n            geom.Direction.EAST,\r\n            geom.Direction.SOUTH,\r\n            geom.Direction.SOUTH,\r\n            geom.Direction.WEST,\r\n            geom.Direction.WEST,\r\n            geom.Direction.NORTH,\r\n            geom.Direction.NORTH,\r\n        ]);\r\n    }\r\n    if (typeof variation === 'undefined') {\r\n        variation = 0.4;\r\n    }\r\n\r\n    let points = new Array<geom.Offset>();\r\n    let bounds = shape.getBounds();\r\n    shape.getOffsets((off) => {\r\n        points.push(new geom.Offset(off.x, off.y));\r\n    });\r\n\r\n    for (let iter = 0; iter < param.iterations; iter ++) {\r\n        // console.info(`iteration ${iter + 1}`);\r\n        ({points, bounds} = blockFractalIteration(random, points, bounds, variation));\r\n    }\r\n\r\n    const segments = new Array<geom.Direction>();\r\n    for (let i = 0; i < points.length - 1; i ++) {\r\n        const curPoint = points[i];\r\n        const nextPoint = points[i + 1];\r\n        if (nextPoint.y === curPoint.y - 1) {\r\n            segments.push(geom.Direction.NORTH);\r\n        } else if (nextPoint.x === curPoint.x + 1) {\r\n            segments.push(geom.Direction.EAST);\r\n        } else if (nextPoint.y === curPoint.y + 1) {\r\n            segments.push(geom.Direction.SOUTH);\r\n        } else if (nextPoint.x === curPoint.x - 1) {\r\n            segments.push(geom.Direction.WEST);\r\n        }\r\n    }\r\n\r\n    return new geom.Path(points[0], segments);\r\n}\r\n","// tslint:disable:no-bitwise\r\n\r\nexport enum Direction {\r\n    NORTH = 0,\r\n    EAST  = 1,\r\n    SOUTH = 2,\r\n    WEST  = 3,\r\n}\r\n\r\nexport const DIRECTIONS = [\r\n    Direction.NORTH,\r\n    Direction.EAST,\r\n    Direction.SOUTH,\r\n    Direction.WEST,\r\n];\r\n\r\nconst DIRECTIONS_STR = [\r\n    'N',\r\n    'E',\r\n    'S',\r\n    'W',\r\n];\r\n\r\nexport function directionToString(dir: Direction) {\r\n    return DIRECTIONS_STR[dir];\r\n}\r\n\r\nexport function directionOpposite(dir: Direction) {\r\n    return ((dir + 2) & 3) as Direction;\r\n}\r\n","import * as geom from '.';\r\n\r\n// tslint:disable:no-bitwise\r\n\r\nexport enum DirectionFlags {\r\n    NONE  = 0,\r\n    NORTH = 1,\r\n    EAST  = 2,\r\n    SOUTH = 4,\r\n    WEST  = 8,\r\n    ALL   = 15,\r\n}\r\n\r\nexport function directionFlagsToString(flags: DirectionFlags) {\r\n    let ret = '[';\r\n    if ((flags & DirectionFlags.NORTH) !== 0) {\r\n        ret += 'N';\r\n    }\r\n    if ((flags & DirectionFlags.EAST) !== 0) {\r\n        ret += 'E';\r\n    }\r\n    if ((flags & DirectionFlags.SOUTH) !== 0) {\r\n        ret += 'S';\r\n    }\r\n    if ((flags & DirectionFlags.WEST) !== 0) {\r\n        ret += 'W';\r\n    }\r\n    return ret + ']';\r\n}\r\n\r\n// conversion\r\n\r\nexport function directionFlagsFromDirection(dir: geom.Direction) {\r\n    return (1 << dir) as DirectionFlags;\r\n}\r\n","import * as geom from '.';\r\n\r\nconst X_FROM_DIRECTION = [  0, 1, 0, -1 ];\r\nconst Y_FROM_DIRECTION = [ -1, 0, 1,  0 ];\r\n\r\nexport interface OffsetLike {\r\n    readonly x: number;\r\n    readonly y: number;\r\n}\r\n\r\nexport class Offset implements OffsetLike {\r\n    x: number;\r\n    y: number;\r\n\r\n    constructor();\r\n    constructor(x: number, y: number);\r\n    constructor(x?: number, y?: number) {\r\n        if (typeof x === 'undefined') {\r\n            x = 0;\r\n        }\r\n        if (typeof y === 'undefined') {\r\n            y = 0;\r\n        }\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `(${this.x},${this.y})`;\r\n    }\r\n\r\n    equals(other: OffsetLike) {\r\n        return this.x === other.x && this.y === other.y;\r\n    }\r\n\r\n    // chebyshev: can move in any direction (diagonals are ok)\r\n    get magnitudeChebyshev() {\r\n        return Math.max(Math.abs(this.x), Math.abs(this.y));\r\n    }\r\n\r\n    // manhattan: can move only in cardinal directions (no diagonals)\r\n    get magnitudeManhattan(): number {\r\n        return Math.abs(this.x) + Math.abs(this.y);\r\n    }\r\n\r\n    // mutators\r\n\r\n    set(x: number, y: number) {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n\r\n    copyFrom(other: OffsetLike) {\r\n        this.x = other.x;\r\n        this.y = other.y;\r\n        return this;\r\n    }\r\n\r\n    setFromDirection(dir: geom.Direction) {\r\n        this.x = X_FROM_DIRECTION[dir];\r\n        this.y = Y_FROM_DIRECTION[dir];\r\n        return this;\r\n    }\r\n\r\n    add(x: number, y: number) {\r\n        this.x += x;\r\n        this.y += y;\r\n        return this;\r\n    }\r\n\r\n    addSize(size: geom.SizeLike) {\r\n        this.x += size.width;\r\n        this.y += size.height;\r\n        return this;\r\n    }\r\n\r\n    addOffset(off: OffsetLike) {\r\n        this.x += off.x;\r\n        this.y += off.y;\r\n        return this;\r\n    }\r\n\r\n    addDirection(dir: geom.Direction) {\r\n        this.x += X_FROM_DIRECTION[dir];\r\n        this.y += Y_FROM_DIRECTION[dir];\r\n        return this;\r\n    }\r\n\r\n    addCardinalDirection(dir: geom.Direction) {\r\n        this.x += X_FROM_DIRECTION[dir];\r\n        this.y += Y_FROM_DIRECTION[dir];\r\n        return this;\r\n    }\r\n\r\n    subtractOffset(off: OffsetLike) {\r\n        this.x -= off.x;\r\n        this.y -= off.y;\r\n        return this;\r\n    }\r\n\r\n    multiply(factor: number) {\r\n        this.x *= factor;\r\n        this.y *= factor;\r\n        return this;\r\n    }\r\n\r\n    // utilities\r\n\r\n    // chebyshev: can move in any direction (diagonals are ok)\r\n    distanceChebyshev(other: OffsetLike) {\r\n        return this.subtractOffset(other).magnitudeChebyshev;\r\n    }\r\n\r\n    // manhattan: can move only in cardinal directions (no diagonals)\r\n    distanceManhattan(other?: OffsetLike): number {\r\n        return this.subtractOffset(other).magnitudeManhattan;\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nexport interface SizeLike {\r\n    readonly width: number;\r\n    readonly height: number;\r\n}\r\n\r\nexport class Size implements SizeLike {\r\n    width: number;\r\n    height: number;\r\n\r\n    constructor();\r\n    constructor(width: number, height: number);\r\n    constructor(width?: number, height?: number) {\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `(${this.width}x${this.height})`;\r\n    }\r\n\r\n    equals(other: SizeLike) {\r\n        return this.width === other.width && this.height === other.height;\r\n    }\r\n\r\n    get empty() {\r\n        return this.width === 0 || this.height === 0;\r\n    }\r\n\r\n    get area() {\r\n        return this.width * this.height;\r\n    }\r\n\r\n    // mutators\r\n\r\n    set(width: number, height: number) {\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n\r\n    copyFrom(other: SizeLike) {\r\n        this.width = other.width;\r\n        this.height = other.height;\r\n        return this;\r\n    }\r\n\r\n    add(width: number, height: number) {\r\n        this.width += width;\r\n        this.height += height;\r\n        return this;\r\n    }\r\n\r\n    addOffset(off: geom.OffsetLike) {\r\n        this.width += off.x;\r\n        this.height += off.y;\r\n        return this;\r\n    }\r\n\r\n    multiply(factor: number) {\r\n        this.width *= factor;\r\n        this.height *= factor;\r\n        return this;\r\n    }\r\n\r\n    // TODO: rotate\r\n\r\n    // utilities\r\n\r\n    containsOffset(off: geom.OffsetLike) {\r\n        return off.x >= 0 && off.y >= 0 && off.x < this.width && off.y < this.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return off.y * this.width + off.x;\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nexport interface RectangleLike extends geom.SizeLike {\r\n    readonly westX: number;\r\n    readonly northY: number;\r\n}\r\n\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\nexport class Rectangle implements RectangleLike, geom.SizeLike {\r\n    northWest: geom.Offset;\r\n    size: geom.Size;\r\n\r\n    constructor();\r\n    constructor(westX: number, northY: number, width: number, height: number);\r\n    constructor(westX?: number, northY?: number, width?: number, height?: number) {\r\n        if (typeof westX === 'undefined') {\r\n            westX = 0;\r\n        }\r\n        if (typeof northY === 'undefined') {\r\n            northY = 0;\r\n        }\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        this.northWest = new geom.Offset(westX, northY);\r\n        this.size = new geom.Size(width, height);\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `(${this.westX},${this.northY} ${this.width}x${this.height})`;\r\n    }\r\n\r\n    equals(other: RectangleLike) {\r\n        return this.westX === other.westX && this.northY === other.northY && this.size.equals(other);\r\n    }\r\n\r\n    get northY() {\r\n        return this.northWest.y;\r\n    }\r\n\r\n    get southY() {\r\n        return this.northWest.y + this.size.height - 1;\r\n    }\r\n\r\n    get westX() {\r\n        return this.northWest.x;\r\n    }\r\n\r\n    get eastX() {\r\n        return this.northWest.x + this.size.width - 1;\r\n    }\r\n\r\n    get width() {\r\n        return this.size.width;\r\n    }\r\n\r\n    get height() {\r\n        return this.size.height;\r\n    }\r\n\r\n    get empty() {\r\n        return this.size.empty;\r\n    }\r\n\r\n    get area() {\r\n        return this.size.area;\r\n    }\r\n\r\n    // mutators\r\n\r\n    set(westX: number, northY: number, width: number, height: number) {\r\n        this.northWest.set(westX, northY);\r\n        this.size.set(width, height);\r\n        return this;\r\n    }\r\n\r\n    copyFrom(other: RectangleLike) {\r\n        this.northWest.set(other.westX, other.northY);\r\n        this.size.set(other.width, other.height);\r\n        return this;\r\n    }\r\n\r\n    extendToInclude(off: geom.OffsetLike) {\r\n        const dx = off.x - this.westX;\r\n        if (dx < 0) {\r\n            this.size.width -= dx;\r\n            this.northWest.x = off.x;\r\n        } else if (dx >= this.size.width) {\r\n            this.size.width = dx + 1;\r\n        }\r\n        const dy = off.y - this.northWest.y;\r\n        if (dy < 0) {\r\n            this.size.height -= dy;\r\n            this.northWest.y = off.y;\r\n        } else if (dy >= this.size.height) {\r\n            this.size.height = dy + 1;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // utilities\r\n\r\n    containsOffset(off: geom.OffsetLike) {\r\n        return this.size.containsOffset(LOCAL_OFF.copyFrom(off).subtractOffset(this.northWest));\r\n    }\r\n\r\n    containsRectangle(other: RectangleLike) {\r\n        LOCAL_OFF.set(other.westX, other.northY).subtractOffset(this.northWest);\r\n        if (!this.size.containsOffset(LOCAL_OFF)) {\r\n            return false;\r\n        }\r\n        if (other.width === 0 && other.height === 0) {\r\n            return false;\r\n        }\r\n        return this.size.containsOffset(LOCAL_OFF.add(other.width - 1, other.height - 1));\r\n    }\r\n\r\n    overlapsRectangle(other: RectangleLike) {\r\n        return this.northY <= other.northY + other.height - 1\r\n            && this.southY >= other.northY\r\n            && this.westX <= other.westX + other.width - 1\r\n            && this.eastX >= other.westX\r\n            && !this.empty\r\n            && other.width !== 0 && other.height !== 0;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this.size.index(LOCAL_OFF.copyFrom(off).subtractOffset(this.northWest));\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nexport class Mask implements geom.SizeLike {\r\n    private readonly _size = new geom.Size();\r\n    private readonly _bits: number[];\r\n    // TODO consider Uint8Array for bits\r\n\r\n    constructor(size: geom.SizeLike, initialValue = false) {\r\n        this._size.copyFrom(size);\r\n        this._bits = new Array<number>(Math.ceil(this._size.area / 32)).fill(initialValue ? 0xffffffff : 0);\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        let ret = '';\r\n        const off = new geom.Offset();\r\n        for (let y = 0; y < this._size.height; y ++) {\r\n            for (let x = 0; x < this._size.width; x ++) {\r\n                off.set(x, y);\r\n                ret += this.get(off.set(x, y)) ? '☑' : '☐';\r\n            }\r\n            ret += '\\n';\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    get width() {\r\n        return this._size.width;\r\n    }\r\n\r\n    get height() {\r\n        return this._size.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this._size.index(off);\r\n    }\r\n\r\n    getAt(index: number) {\r\n        // tslint:disable:no-bitwise\r\n        const arrayIndex = index >>> 5;\r\n        const bitMask = 1 << (index & 31);\r\n        return (this._bits[arrayIndex] & bitMask) !== 0;\r\n        // tslint:enable:no-bitwise\r\n    }\r\n\r\n    get(off: geom.OffsetLike) {\r\n        return this.getAt(this.index(off));\r\n    }\r\n\r\n    // mutators\r\n\r\n    setAt(index: number, value: boolean) {\r\n        // tslint:disable:no-bitwise\r\n        const arrayIndex = index >>> 5;\r\n        const bitMask = 1 << (index & 31);\r\n        if (value) {\r\n            this._bits[arrayIndex] |= bitMask;\r\n        } else {\r\n            this._bits[arrayIndex] &= ~bitMask;\r\n        }\r\n        // tslint:enable:no-bitwise\r\n        return this;\r\n    }\r\n\r\n    set(off: geom.OffsetLike, value: boolean) {\r\n        return this.setAt(this.index(off), value);\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\nexport class MaskRect implements geom.RectangleLike {\r\n    private readonly _rectangle = new geom.Rectangle();\r\n    private readonly _mask: geom.Mask;\r\n    private readonly _outsideValue: boolean;\r\n\r\n    constructor(rect: geom.RectangleLike, initialValue = false, outsideValue = false) {\r\n        this._rectangle.copyFrom(rect);\r\n        this._mask = new geom.Mask(rect, initialValue);\r\n        this._outsideValue = outsideValue;\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `${this._rectangle.northWest}/${this._outsideValue}\\n${this._mask}`;\r\n    }\r\n\r\n    get westX() {\r\n        return this._rectangle.westX;\r\n    }\r\n\r\n    get northY() {\r\n        return this._rectangle.northY;\r\n    }\r\n\r\n    get width() {\r\n        return this._rectangle.width;\r\n    }\r\n\r\n    get height() {\r\n        return this._rectangle.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this._mask.index(LOCAL_OFF.copyFrom(off).subtractOffset(this._rectangle.northWest));\r\n    }\r\n\r\n    getAt(index: number) {\r\n        return this._mask.getAt(index);\r\n    }\r\n\r\n    get(off: geom.OffsetLike) {\r\n        if (!this._rectangle.containsOffset(off)) {\r\n            return this._outsideValue;\r\n        }\r\n        return this._mask.getAt(this._rectangle.index(off));\r\n    }\r\n\r\n    // mutators\r\n\r\n    setAt(index: number, value: boolean) {\r\n        this._mask.setAt(index, value);\r\n        return this;\r\n    }\r\n\r\n    set(off: geom.OffsetLike, value: boolean) {\r\n        this._mask.setAt(this._rectangle.index(off), value);\r\n        return this;\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nexport class RasterMask implements geom.RectangleLike, geom.SizeLike {\r\n    northWest: geom.Offset;\r\n    size: geom.Size;\r\n    private _lines: number[][];\r\n\r\n    constructor(bounds: geom.RectangleLike, lines: number[][]) {\r\n        this.northWest = new geom.Offset(bounds.westX, bounds.northY);\r\n        this.size = new geom.Size(bounds.width, bounds.height);\r\n        this._lines = lines;\r\n    }\r\n\r\n    toString() {\r\n        let shape = '';\r\n        for (let y = 0; y < this.height; y ++) {\r\n            const line = this._lines[y];\r\n            let x = this.westX;\r\n            for (let i = 0; i < line.length; i += 2) {\r\n                const start = line[i];\r\n                const end = line[i + 1];\r\n                while (x < start) {\r\n                    shape += '∙';\r\n                    x ++;\r\n                }\r\n                while (x < end) {\r\n                    shape += '█';\r\n                    x ++;\r\n                }\r\n            }\r\n            while (x <= this.eastX) {\r\n                shape += '∙';\r\n                x ++;\r\n            }\r\n            shape += '\\n';\r\n        }\r\n        return `${this.northWest}\\n${shape}`;\r\n    }\r\n\r\n    // accessors\r\n\r\n    get northY() {\r\n        return this.northWest.y;\r\n    }\r\n\r\n    get southY() {\r\n        return this.northWest.y + this.size.height - 1;\r\n    }\r\n\r\n    get westX() {\r\n        return this.northWest.x;\r\n    }\r\n\r\n    get eastX() {\r\n        return this.northWest.x + this.size.width - 1;\r\n    }\r\n\r\n    get width() {\r\n        return this.size.width;\r\n    }\r\n\r\n    get height() {\r\n        return this.size.height;\r\n    }\r\n\r\n    get(x: number, y: number) {\r\n        if (y < this.northY || y > this.southY) {\r\n            return false;\r\n        }\r\n        const line = this._lines[y - this.northY];\r\n        for (let i = 0; i < line.length; i += 2) {\r\n            if (x >= line[i] && x < line[i + 1]) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    bandsAt(y: number, callback: (westX: number, eastX: number) => void) {\r\n        if (y < this.northY || y > this.southY) {\r\n            return;\r\n        }\r\n        const line = this._lines[y - this.northY];\r\n        for (let i = 0; i < line.length; i += 2) {\r\n            callback(line[i], line[i + 1] - 1);\r\n        }\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\nfunction sortedInsert(array: number[], value: number) {\r\n    let low = 0;\r\n    let high = array.length;\r\n\r\n    while (low < high) {\r\n        // tslint:disable-next-line:no-bitwise\r\n        const mid = (low + high) >>> 1;\r\n        if (array[mid] < value) {\r\n            low = mid + 1;\r\n        } else {\r\n            high = mid;\r\n        }\r\n    }\r\n\r\n    array.splice(low, 0, value);\r\n}\r\n\r\nexport class Path {\r\n    start: geom.Offset;\r\n    segments: geom.Direction[];\r\n\r\n    constructor();\r\n    constructor(start: geom.OffsetLike, segments: geom.Direction[]);\r\n    constructor(start?: geom.OffsetLike, segments?: geom.Direction[]) {\r\n        this.start = new geom.Offset();\r\n        if (typeof start !== 'undefined') {\r\n            this.start.copyFrom(start);\r\n        }\r\n        if (typeof segments === 'undefined') {\r\n            segments = new Array<geom.Direction>();\r\n        }\r\n        this.segments = segments;\r\n    }\r\n\r\n    toString() {\r\n        return `${this.start.toString()}:`\r\n            + `${this.segments.map((segment) => geom.directionToString(segment)).join('')}`;\r\n    }\r\n\r\n    getIsClosed() {\r\n        LOCAL_OFF.copyFrom(this.start);\r\n        for (const segment of this.segments) {\r\n            LOCAL_OFF.addDirection(segment);\r\n        }\r\n        return this.start.equals(LOCAL_OFF);\r\n    }\r\n\r\n    getOffsets(callback: (off: geom.OffsetLike) => void) {\r\n        const cursor = new geom.Offset();\r\n        cursor.copyFrom(this.start);\r\n        callback(cursor);\r\n        for (const segment of this.segments) {\r\n            cursor.addDirection(segment);\r\n            callback(cursor);\r\n        }\r\n    }\r\n\r\n    getBounds(): geom.Rectangle {\r\n        let northY = this.start.y;\r\n        let southY = northY;\r\n        let westX = this.start.x;\r\n        let eastX = westX;\r\n        LOCAL_OFF.copyFrom(this.start);\r\n        for (const segment of this.segments) {\r\n            LOCAL_OFF.addDirection(segment);\r\n            switch (segment) {\r\n            case geom.Direction.NORTH:\r\n                northY = Math.min(northY, LOCAL_OFF.y);\r\n                break;\r\n            case geom.Direction.EAST:\r\n                eastX = Math.max(eastX, LOCAL_OFF.x);\r\n                break;\r\n            case geom.Direction.SOUTH:\r\n                southY = Math.max(southY, LOCAL_OFF.y);\r\n                break;\r\n            case geom.Direction.WEST:\r\n                westX = Math.min(westX, LOCAL_OFF.x);\r\n                break;\r\n            }\r\n        }\r\n        return new geom.Rectangle(westX, northY, eastX - westX + 1, southY - northY + 1);\r\n    }\r\n\r\n    getArea() {\r\n        let total = 0;\r\n        LOCAL_OFF.copyFrom(this.start);\r\n        for (const segment of this.segments) {\r\n            LOCAL_OFF.addDirection(segment);\r\n            switch (segment) {\r\n            case geom.Direction.NORTH:\r\n                total -= LOCAL_OFF.x;\r\n                break;\r\n            case geom.Direction.SOUTH:\r\n                total += LOCAL_OFF.x;\r\n                break;\r\n            }\r\n        }\r\n        return Math.abs(total);\r\n    }\r\n\r\n    rasterize(bounds?: geom.RectangleLike): geom.RasterMask {\r\n        const lines = new Array<number[]>();\r\n        if (typeof bounds === 'undefined') {\r\n            bounds = this.getBounds();\r\n        }\r\n        LOCAL_OFF.copyFrom(this.start);\r\n        const {northY} = bounds;\r\n        const southY = northY + bounds.height - 1;\r\n        for (let y = northY; y < southY; y ++) {\r\n            lines.push([]);\r\n        }\r\n        LOCAL_OFF.copyFrom(this.start);\r\n        for (const segment of this.segments) {\r\n            if (segment === geom.Direction.SOUTH) {\r\n                sortedInsert(lines[LOCAL_OFF.y - northY], LOCAL_OFF.x);\r\n            }\r\n            LOCAL_OFF.addDirection(segment);\r\n            if (segment === geom.Direction.NORTH) {\r\n                sortedInsert(lines[LOCAL_OFF.y - northY], LOCAL_OFF.x);\r\n            }\r\n        }\r\n        return new geom.RasterMask({\r\n            westX: bounds.westX,\r\n            northY: bounds.northY,\r\n            width: bounds.width - 1,\r\n            height: bounds.height - 1,\r\n        }, lines);\r\n    }\r\n}\r\n"],"sourceRoot":""}
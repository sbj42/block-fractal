{"version":3,"sources":["webpack://BlockFractal/./src/block-fractal.ts","webpack://BlockFractal/./src/geom/direction-flags.ts","webpack://BlockFractal/./src/geom/direction.ts","webpack://BlockFractal/./src/geom/index.ts","webpack://BlockFractal/./src/geom/mask-rect.ts","webpack://BlockFractal/./src/geom/mask.ts","webpack://BlockFractal/./src/geom/offset.ts","webpack://BlockFractal/./src/geom/path.ts","webpack://BlockFractal/./src/geom/raster-mask.ts","webpack://BlockFractal/./src/geom/rectangle.ts","webpack://BlockFractal/./src/geom/size.ts","webpack://BlockFractal/./src/index.ts","webpack://BlockFractal/webpack/bootstrap","webpack://BlockFractal/webpack/startup"],"names":["nextToLastMatch","points","next","length","equals","addPoint","mask","set","splice","push","verticalHelper","random","variation","newPoints","i","p1","p2","x","yDir","y","np3","geom","Offset","get","index","findIndex","point","v","Math","floor","np1","np2","horizontalHelper","xDir","blockFractalIteration","bounds","Array","newBounds","Rectangle","westX","northY","width","height","MaskRect","param","shape","Path","Direction","EAST","SOUTH","WEST","NORTH","getBounds","getOffsets","off","iter","iterations","segments","curPoint","nextPoint","DirectionFlags","flags","ret","dir","DIRECTIONS","DIRECTIONS_STR","LOCAL_OFF","rect","initialValue","outsideValue","_rectangle","this","copyFrom","_mask","Mask","_outsideValue","toString","northWest","subtractOffset","getAt","containsOffset","setAt","value","size","_size","Size","_bits","ceil","area","fill","arrayIndex","bitMask","X_FROM_DIRECTION","Y_FROM_DIRECTION","other","max","abs","setFromDirection","add","addSize","addOffset","addDirection","addCardinalDirection","multiply","factor","distanceChebyshev","magnitudeChebyshev","distanceManhattan","magnitudeManhattan","sortedInsert","array","low","high","mid","start","map","segment","directionToString","join","getIsClosed","callback","cursor","southY","eastX","min","getArea","total","rasterize","lines","RasterMask","_lines","line","end","bandsAt","empty","extendToInclude","dx","dy","containsRectangle","overlapsRectangle","makeBlockFractal","__webpack_module_cache__","__webpack_require__","moduleId","exports","module","__webpack_modules__","call"],"mappings":"iJAAA,aASA,SAASA,EAAgBC,EAAuBC,GAC5C,OAAOD,EAAOE,OAAS,GAAKF,EAAOA,EAAOE,OAAS,GAAGC,OAAOF,GAGjE,SAASG,EAASJ,EAAuBK,EAAqBJ,GACtDF,EAAgBC,EAAQC,GACxBI,EAAKC,IAAIN,EAAOO,OAAOP,EAAOE,OAAS,EAAG,GAAG,IAAI,IAEjDF,EAAOQ,KAAKP,GACZI,EAAKC,IAAIL,GAAM,IAIvB,SAASQ,EAAeT,EAAuBU,EAAsBC,EAC7CC,EAA0BP,EAAqBQ,EAC/CC,EAAiBC,GAGrC,IAFA,IAAMC,EAAI,EAAIF,EAAGE,EACXC,EAAOF,EAAGG,EAAIJ,EAAGI,E,WACdA,GACL,IAAMC,EAAM,IAAIC,EAAKC,OAAOL,EAAGE,EAAID,GAEnC,GAAIlB,EAAgBa,EAAWO,G,OAI3Bd,EAAKC,IAAIM,EAAUL,OAAOK,EAAUV,OAAS,EAAG,GAAG,IAAI,G,WAG3D,GAAIW,IAAMb,EAAOE,OAAS,GAAKG,EAAKiB,IAAIH,GAAM,CAK1C,IAFA,IAAMI,EAAQX,EAAUY,WAAU,SAACC,GAAU,OAAAA,EAAMtB,OAAOgB,MAEtC,MAAAP,EAAUL,OAAO,EAAGgB,GAApB,eAA4B,CAA3C,IAAME,EAAK,KACZpB,EAAKC,IAAImB,GAAO,G,OAEpBrB,EAASQ,EAAWP,EAAMc,G,QAG9B,GAAIT,IAAWC,EAAW,CACtB,IAAMe,EAA+B,EAA3BC,KAAKC,MAAiB,EAAXlB,KAAoB,EACnCmB,EAAM,IAAIT,EAAKC,OAAOL,EAAIU,EAAGR,GAC7BY,EAAM,IAAIV,EAAKC,OAAOL,EAAIU,EAAGR,EAAID,GAClCZ,EAAKiB,IAAIQ,IACLzB,EAAKiB,IAAIO,KAAQ9B,EAAgBa,EAAWiB,KAC7CzB,EAASQ,EAAWP,EAAMwB,GAC1BzB,EAASQ,EAAWP,EAAMyB,IAItC1B,EAASQ,EAAWP,EAAMc,IAhCrBD,EAAI,EAAIJ,EAAGI,EAAGA,IAAM,EAAIH,EAAGG,G,YAA3BA,GAA8BA,GAAKD,IAoChD,SAASc,EAAiB/B,EAAuBU,EAAsBC,EAC7CC,EAA0BP,EAAqBQ,EAC/CC,EAAiBC,GAGvC,IAFA,IAAMG,EAAI,EAAIJ,EAAGI,EACXc,EAAOjB,EAAGC,EAAIF,EAAGE,E,WACdA,GACL,IAAMG,EAAM,IAAIC,EAAKC,OAAOL,EAAIgB,EAAMd,GAEtC,GAAInB,EAAgBa,EAAWO,G,OAI3Bd,EAAKC,IAAIM,EAAUL,OAAOK,EAAUV,OAAS,EAAG,GAAG,IAAI,G,WAG3D,GAAIW,IAAMb,EAAOE,OAAS,GAAKG,EAAKiB,IAAIH,GAAM,CAK1C,IAFA,IAAMI,EAAQX,EAAUY,WAAU,SAACC,GAAU,OAAAA,EAAMtB,OAAOgB,MAEtC,MAAAP,EAAUL,OAAO,EAAGgB,GAApB,eAA4B,CAA3C,IAAME,EAAK,KACZpB,EAAKC,IAAImB,GAAO,G,OAEpBrB,EAASQ,EAAWP,EAAMc,G,QAG9B,GAAIT,IAAWC,EAAW,CACtB,IAAMe,EAA+B,EAA3BC,KAAKC,MAAiB,EAAXlB,KAAoB,EACnCmB,EAAM,IAAIT,EAAKC,OAAOL,EAAGE,EAAIQ,GAC7BI,EAAM,IAAIV,EAAKC,OAAOL,EAAIgB,EAAMd,EAAIQ,GACrCrB,EAAKiB,IAAIQ,IACLzB,EAAKiB,IAAIO,KAAQ9B,EAAgBa,EAAWiB,KAC7CzB,EAASQ,EAAWP,EAAMwB,GAC1BzB,EAASQ,EAAWP,EAAMyB,IAItC1B,EAASQ,EAAWP,EAAMc,IAhCrBH,EAAI,EAAIF,EAAGE,EAAGA,IAAM,EAAID,EAAGC,G,YAA3BA,GAA8BA,GAAKgB,IAoChD,SAASC,EAAsBvB,EAAsBV,EACtBkC,EAA4BvB,GAUvD,IATA,IAAMC,EAAY,IAAIuB,MAChBC,EAAY,IAAIhB,EAAKiB,UACR,EAAfH,EAAOI,MAAY,EACH,EAAhBJ,EAAOK,OAAa,EACL,EAAfL,EAAOM,MAAY,EACH,EAAhBN,EAAOO,OAAa,GAGlBpC,EAAO,IAAIe,EAAKsB,SAASN,GACtBvB,EAAI,EAAGA,EAAIb,EAAOE,OAAS,EAAGW,IAAM,CACzC,IAAMC,EAAKd,EAAOa,GACZE,EAAKf,EAAOa,EAAI,GACZ,IAANA,GACAT,EAASQ,EAAWP,EAAM,IAAIe,EAAKC,OAAc,EAAPP,EAAGE,EAAc,EAAPF,EAAGI,IAEvDJ,EAAGE,IAAMD,EAAGC,EACZP,EAAeT,EAAQU,EAAQC,EAAWC,EAAWP,EAAMQ,EAAGC,EAAIC,GAElEgB,EAAiB/B,EAAQU,EAAQC,EAAWC,EAAWP,EAAMQ,EAAGC,EAAIC,GAG5E,MAAO,CACHf,OAAQY,EACRsB,OAAQE,GAIhB,4BAAiCO,G,MACxBjC,EAA4BiC,EAAK,OAAzBC,EAAoBD,EAAK,MAAlBhC,EAAagC,EAAK,eAChB,IAAXjC,IACPA,EAASiB,KAAKjB,aAEG,IAAVkC,IACPA,EAAQ,IAAIxB,EAAKyB,KAAK,CAAC7B,GAAI,EAAGE,GAAI,GAAI,CAClCE,EAAK0B,UAAUC,KACf3B,EAAK0B,UAAUC,KACf3B,EAAK0B,UAAUE,MACf5B,EAAK0B,UAAUE,MACf5B,EAAK0B,UAAUG,KACf7B,EAAK0B,UAAUG,KACf7B,EAAK0B,UAAUI,MACf9B,EAAK0B,UAAUI,cAGE,IAAdvC,IACPA,EAAY,IAGhB,IAAIX,EAAS,IAAImC,MACbD,EAASU,EAAMO,YACnBP,EAAMQ,YAAW,SAACC,GACdrD,EAAOQ,KAAK,IAAIY,EAAKC,OAAOgC,EAAIrC,EAAGqC,EAAInC,OAG3C,IAAK,IAAIoC,EAAO,EAAGA,EAAOX,EAAMY,WAAYD,IAEvC,EAAmBrB,EAAsBvB,EAAQV,EAAQkC,EAAQvB,GAAhEX,EAAM,SAAEkC,EAAM,SAIpB,IADA,IAAMsB,EAAW,IAAIrB,MACZtB,EAAI,EAAGA,EAAIb,EAAOE,OAAS,EAAGW,IAAM,CACzC,IAAM4C,EAAWzD,EAAOa,GAClB6C,EAAY1D,EAAOa,EAAI,GACzB6C,EAAUxC,IAAMuC,EAASvC,EAAI,EAC7BsC,EAAShD,KAAKY,EAAK0B,UAAUI,OACtBQ,EAAU1C,IAAMyC,EAASzC,EAAI,EACpCwC,EAAShD,KAAKY,EAAK0B,UAAUC,MACtBW,EAAUxC,IAAMuC,EAASvC,EAAI,EACpCsC,EAAShD,KAAKY,EAAK0B,UAAUE,OACtBU,EAAU1C,IAAMyC,EAASzC,EAAI,GACpCwC,EAAShD,KAAKY,EAAK0B,UAAUG,MAIrC,OAAO,IAAI7B,EAAKyB,KAAK7C,EAAO,GAAIwD,K,WChLpC,IAAYG,E,gIAAZ,SAAYA,GACR,mBACA,qBACA,mBACA,qBACA,mBACA,kBANJ,CAAYA,EAAA,EAAAA,iBAAA,EAAAA,eAAc,KAS1B,kCAAuCC,GACnC,IAAIC,EAAM,IAaV,OAZuC,IAAlCD,EAAQD,EAAeT,SACxBW,GAAO,KAE2B,IAAjCD,EAAQD,EAAeZ,QACxBc,GAAO,KAE4B,IAAlCD,EAAQD,EAAeX,SACxBa,GAAO,KAE2B,IAAjCD,EAAQD,EAAeV,QACxBY,GAAO,KAEJA,EAAM,KAKjB,uCAA4CC,GACxC,OAAQ,GAAKA,I,YC/BjB,IAAYhB,E,yHAAZ,SAAYA,GACR,qBACA,mBACA,qBACA,mBAJJ,CAAYA,EAAA,EAAAA,YAAA,EAAAA,UAAS,KAOR,EAAAiB,WAAa,CACtBjB,EAAUI,MACVJ,EAAUC,KACVD,EAAUE,MACVF,EAAUG,MAGd,IAAMe,EAAiB,CACnB,IACA,IACA,IACA,KAGJ,6BAAkCF,GAC9B,OAAOE,EAAeF,IAG1B,6BAAkCA,GAC9B,OAASA,EAAM,EAAK,I,8YC5BxB,YACA,WACA,YACA,YACA,YACA,YACA,YACA,YACA,a,iFCRA,aAEMG,EAAY,IAAI7C,EAAKC,OAE3B,aAKI,WAAY6C,EAA0BC,EAAsBC,QAAtB,IAAAD,OAAA,QAAsB,IAAAC,OAAA,GAJ3C,KAAAC,WAAa,IAAIjD,EAAKiB,UAKnCiC,KAAKD,WAAWE,SAASL,GACzBI,KAAKE,MAAQ,IAAIpD,EAAKqD,KAAKP,EAAMC,GACjCG,KAAKI,cAAgBN,EAmD7B,OA9CI,YAAAO,SAAA,WACI,OAAUL,KAAKD,WAAWO,UAAS,IAAIN,KAAKI,cAAa,KAAKJ,KAAKE,OAGvE,sBAAI,oBAAK,C,IAAT,WACI,OAAOF,KAAKD,WAAW/B,O,gCAG3B,sBAAI,qBAAM,C,IAAV,WACI,OAAOgC,KAAKD,WAAW9B,Q,gCAG3B,sBAAI,oBAAK,C,IAAT,WACI,OAAO+B,KAAKD,WAAW7B,O,gCAG3B,sBAAI,qBAAM,C,IAAV,WACI,OAAO8B,KAAKD,WAAW5B,Q,gCAG3B,YAAAlB,MAAA,SAAM8B,GACF,OAAOiB,KAAKE,MAAMjD,MAAM0C,EAAUM,SAASlB,GAAKwB,eAAeP,KAAKD,WAAWO,aAGnF,YAAAE,MAAA,SAAMvD,GACF,OAAO+C,KAAKE,MAAMM,MAAMvD,IAG5B,YAAAD,IAAA,SAAI+B,GACA,OAAKiB,KAAKD,WAAWU,eAAe1B,GAG7BiB,KAAKE,MAAMM,MAAMR,KAAKD,WAAW9C,MAAM8B,IAFnCiB,KAAKI,eAOpB,YAAAM,MAAA,SAAMzD,EAAe0D,GAEjB,OADAX,KAAKE,MAAMQ,MAAMzD,EAAO0D,GACjBX,MAGX,YAAAhE,IAAA,SAAI+C,EAAsB4B,GAEtB,OADAX,KAAKE,MAAMQ,MAAMV,KAAKD,WAAW9C,MAAM8B,GAAM4B,GACtCX,MAEf,EA3DA,GAAa,EAAA5B,Y,6ECJb,aAEA,aAKI,WAAYwC,EAAqBf,QAAA,IAAAA,OAAA,GAJhB,KAAAgB,MAAQ,IAAI/D,EAAKgE,KAK9Bd,KAAKa,MAAMZ,SAASW,GACpBZ,KAAKe,MAAQ,IAAIlD,MAAcR,KAAK2D,KAAKhB,KAAKa,MAAMI,KAAO,KAAKC,KAAKrB,EAAe,WAAa,GA4DzG,OAvDI,YAAAQ,SAAA,WAGI,IAFA,IAAId,EAAM,GACJR,EAAM,IAAIjC,EAAKC,OACZH,EAAI,EAAGA,EAAIoD,KAAKa,MAAM1C,OAAQvB,IAAM,CACzC,IAAK,IAAIF,EAAI,EAAGA,EAAIsD,KAAKa,MAAM3C,MAAOxB,IAClCqC,EAAI/C,IAAIU,EAAGE,GACX2C,GAAOS,KAAKhD,IAAI+B,EAAI/C,IAAIU,EAAGE,IAAM,IAAM,IAE3C2C,GAAO,KAEX,OAAOA,GAGX,sBAAI,oBAAK,C,IAAT,WACI,OAAOS,KAAKa,MAAM3C,O,gCAGtB,sBAAI,qBAAM,C,IAAV,WACI,OAAO8B,KAAKa,MAAM1C,Q,gCAGtB,YAAAlB,MAAA,SAAM8B,GACF,OAAOiB,KAAKa,MAAM5D,MAAM8B,IAG5B,YAAAyB,MAAA,SAAMvD,GAEF,IAAMkE,EAAalE,IAAU,EACvBmE,EAAU,IAAc,GAARnE,GACtB,OAA8C,IAAtC+C,KAAKe,MAAMI,GAAcC,IAIrC,YAAApE,IAAA,SAAI+B,GACA,OAAOiB,KAAKQ,MAAMR,KAAK/C,MAAM8B,KAKjC,YAAA2B,MAAA,SAAMzD,EAAe0D,GAEjB,IAAMQ,EAAalE,IAAU,EACvBmE,EAAU,IAAc,GAARnE,GAOtB,OANI0D,EACAX,KAAKe,MAAMI,IAAeC,EAE1BpB,KAAKe,MAAMI,KAAgBC,EAGxBpB,MAGX,YAAAhE,IAAA,SAAI+C,EAAsB4B,GACtB,OAAOX,KAAKU,MAAMV,KAAK/C,MAAM8B,GAAM4B,IAE3C,EAnEA,GAAa,EAAAR,Q,6ECAb,IAAMkB,EAAmB,CAAG,EAAG,EAAG,GAAI,GAChCC,EAAmB,EAAG,EAAG,EAAG,EAAI,GAOtC,aAMI,WAAY5E,EAAYE,QACH,IAANF,IACPA,EAAI,QAES,IAANE,IACPA,EAAI,GAERoD,KAAKtD,EAAIA,EACTsD,KAAKpD,EAAIA,EAgGjB,OA3FI,YAAAyD,SAAA,WACI,MAAO,IAAIL,KAAKtD,EAAC,IAAIsD,KAAKpD,EAAC,KAG/B,YAAAf,OAAA,SAAO0F,GACH,OAAOvB,KAAKtD,IAAM6E,EAAM7E,GAAKsD,KAAKpD,IAAM2E,EAAM3E,GAIlD,sBAAI,iCAAkB,C,IAAtB,WACI,OAAOS,KAAKmE,IAAInE,KAAKoE,IAAIzB,KAAKtD,GAAIW,KAAKoE,IAAIzB,KAAKpD,K,gCAIpD,sBAAI,iCAAkB,C,IAAtB,WACI,OAAOS,KAAKoE,IAAIzB,KAAKtD,GAAKW,KAAKoE,IAAIzB,KAAKpD,I,gCAK5C,YAAAZ,IAAA,SAAIU,EAAWE,GAGX,OAFAoD,KAAKtD,EAAIA,EACTsD,KAAKpD,EAAIA,EACFoD,MAGX,YAAAC,SAAA,SAASsB,GAGL,OAFAvB,KAAKtD,EAAI6E,EAAM7E,EACfsD,KAAKpD,EAAI2E,EAAM3E,EACRoD,MAGX,YAAA0B,iBAAA,SAAiBlC,GAGb,OAFAQ,KAAKtD,EAAI2E,EAAiB7B,GAC1BQ,KAAKpD,EAAI0E,EAAiB9B,GACnBQ,MAGX,YAAA2B,IAAA,SAAIjF,EAAWE,GAGX,OAFAoD,KAAKtD,GAAKA,EACVsD,KAAKpD,GAAKA,EACHoD,MAGX,YAAA4B,QAAA,SAAQhB,GAGJ,OAFAZ,KAAKtD,GAAKkE,EAAK1C,MACf8B,KAAKpD,GAAKgE,EAAKzC,OACR6B,MAGX,YAAA6B,UAAA,SAAU9C,GAGN,OAFAiB,KAAKtD,GAAKqC,EAAIrC,EACdsD,KAAKpD,GAAKmC,EAAInC,EACPoD,MAGX,YAAA8B,aAAA,SAAatC,GAGT,OAFAQ,KAAKtD,GAAK2E,EAAiB7B,GAC3BQ,KAAKpD,GAAK0E,EAAiB9B,GACpBQ,MAGX,YAAA+B,qBAAA,SAAqBvC,GAGjB,OAFAQ,KAAKtD,GAAK2E,EAAiB7B,GAC3BQ,KAAKpD,GAAK0E,EAAiB9B,GACpBQ,MAGX,YAAAO,eAAA,SAAexB,GAGX,OAFAiB,KAAKtD,GAAKqC,EAAIrC,EACdsD,KAAKpD,GAAKmC,EAAInC,EACPoD,MAGX,YAAAgC,SAAA,SAASC,GAGL,OAFAjC,KAAKtD,GAAKuF,EACVjC,KAAKpD,GAAKqF,EACHjC,MAMX,YAAAkC,kBAAA,SAAkBX,GACd,OAAOvB,KAAKO,eAAegB,GAAOY,oBAItC,YAAAC,kBAAA,SAAkBb,GACd,OAAOvB,KAAKO,eAAegB,GAAOc,oBAE1C,EA9GA,GAAa,EAAAtF,U,6ECVb,aAEM4C,EAAY,IAAI7C,EAAKC,OAE3B,SAASuF,EAAaC,EAAiB5B,GAInC,IAHA,IAAI6B,EAAM,EACNC,EAAOF,EAAM3G,OAEV4G,EAAMC,GAAM,CAEf,IAAMC,EAAOF,EAAMC,IAAU,EACzBF,EAAMG,GAAO/B,EACb6B,EAAME,EAAM,EAEZD,EAAOC,EAIfH,EAAMtG,OAAOuG,EAAK,EAAG7B,GAGzB,iBAMI,WAAYgC,EAAyBzD,GACjCc,KAAK2C,MAAQ,IAAI7F,EAAKC,YACD,IAAV4F,GACP3C,KAAK2C,MAAM1C,SAAS0C,QAEA,IAAbzD,IACPA,EAAW,IAAIrB,OAEnBmC,KAAKd,SAAWA,EAiGxB,OA9FI,YAAAmB,SAAA,WACI,OAAUL,KAAK2C,MAAMtC,WAAU,IACtBL,KAAKd,SAAS0D,KAAI,SAACC,GAAY,OAAA/F,EAAKgG,kBAAkBD,MAAUE,KAAK,KAGlF,YAAAC,YAAA,WACIrD,EAAUM,SAASD,KAAK2C,OACxB,IAAsB,UAAA3C,KAAKd,SAAL,eAAe,CAAhC,IAAM2D,EAAO,KACdlD,EAAUmC,aAAae,GAE3B,OAAO7C,KAAK2C,MAAM9G,OAAO8D,IAG7B,YAAAb,WAAA,SAAWmE,GACP,IAAMC,EAAS,IAAIpG,EAAKC,OACxBmG,EAAOjD,SAASD,KAAK2C,OACrBM,EAASC,GACT,IAAsB,UAAAlD,KAAKd,SAAL,eAAe,CAAhC,IAAM2D,EAAO,KACdK,EAAOpB,aAAae,GACpBI,EAASC,KAIjB,YAAArE,UAAA,WACI,IAAIZ,EAAS+B,KAAK2C,MAAM/F,EACpBuG,EAASlF,EACTD,EAAQgC,KAAK2C,MAAMjG,EACnB0G,EAAQpF,EACZ2B,EAAUM,SAASD,KAAK2C,OACxB,IAAsB,UAAA3C,KAAKd,SAAL,eAAe,CAAhC,IAAM2D,EAAO,KAEd,OADAlD,EAAUmC,aAAae,GACfA,GACR,KAAK/F,EAAK0B,UAAUI,MAChBX,EAASZ,KAAKgG,IAAIpF,EAAQ0B,EAAU/C,GACpC,MACJ,KAAKE,EAAK0B,UAAUC,KAChB2E,EAAQ/F,KAAKmE,IAAI4B,EAAOzD,EAAUjD,GAClC,MACJ,KAAKI,EAAK0B,UAAUE,MAChByE,EAAS9F,KAAKmE,IAAI2B,EAAQxD,EAAU/C,GACpC,MACJ,KAAKE,EAAK0B,UAAUG,KAChBX,EAAQX,KAAKgG,IAAIrF,EAAO2B,EAAUjD,IAI1C,OAAO,IAAII,EAAKiB,UAAUC,EAAOC,EAAQmF,EAAQpF,EAAQ,EAAGmF,EAASlF,EAAS,IAGlF,YAAAqF,QAAA,WACI,IAAIC,EAAQ,EACZ5D,EAAUM,SAASD,KAAK2C,OACxB,IAAsB,UAAA3C,KAAKd,SAAL,eAAe,CAAhC,IAAM2D,EAAO,KAEd,OADAlD,EAAUmC,aAAae,GACfA,GACR,KAAK/F,EAAK0B,UAAUI,MAChB2E,GAAS5D,EAAUjD,EACnB,MACJ,KAAKI,EAAK0B,UAAUE,MAChB6E,GAAS5D,EAAUjD,GAI3B,OAAOW,KAAKoE,IAAI8B,IAGpB,YAAAC,UAAA,SAAU5F,GACN,IAAM6F,EAAQ,IAAI5F,WACI,IAAXD,IACPA,EAASoC,KAAKnB,aAElBc,EAAUM,SAASD,KAAK2C,OAGxB,IAFO,IAAA1E,EAAUL,EAAM,OACjBuF,EAASlF,EAASL,EAAOO,OAAS,EAC/BvB,EAAIqB,EAAQrB,EAAIuG,EAAQvG,IAC7B6G,EAAMvH,KAAK,IAEfyD,EAAUM,SAASD,KAAK2C,OACxB,IAAsB,UAAA3C,KAAKd,SAAL,eAAe,CAAhC,IAAM2D,EAAO,KACVA,IAAY/F,EAAK0B,UAAUE,OAC3B4D,EAAamB,EAAM9D,EAAU/C,EAAIqB,GAAS0B,EAAUjD,GAExDiD,EAAUmC,aAAae,GACnBA,IAAY/F,EAAK0B,UAAUI,OAC3B0D,EAAamB,EAAM9D,EAAU/C,EAAIqB,GAAS0B,EAAUjD,GAG5D,OAAO,IAAII,EAAK4G,WAAW,CACvB1F,MAAOJ,EAAOI,MACdC,OAAQL,EAAOK,OACfC,MAAON,EAAOM,MAAQ,EACtBC,OAAQP,EAAOO,OAAS,GACzBsF,IAEX,EA/GA,GAAa,EAAAlF,Q,mFCrBb,aAEA,aAKI,WAAYX,EAA4B6F,GACpCzD,KAAKM,UAAY,IAAIxD,EAAKC,OAAOa,EAAOI,MAAOJ,EAAOK,QACtD+B,KAAKY,KAAO,IAAI9D,EAAKgE,KAAKlD,EAAOM,MAAON,EAAOO,QAC/C6B,KAAK2D,OAASF,EA6EtB,OA1EI,YAAApD,SAAA,WAEI,IADA,IAAI/B,EAAQ,GACH1B,EAAI,EAAGA,EAAIoD,KAAK7B,OAAQvB,IAAM,CAGnC,IAFA,IAAMgH,EAAO5D,KAAK2D,OAAO/G,GACrBF,EAAIsD,KAAKhC,MACJzB,EAAI,EAAGA,EAAIqH,EAAKhI,OAAQW,GAAK,EAAG,CAGrC,IAFA,IAAMoG,EAAQiB,EAAKrH,GACbsH,EAAMD,EAAKrH,EAAI,GACdG,EAAIiG,GACPrE,GAAS,IACT5B,IAEJ,KAAOA,EAAImH,GACPvF,GAAS,IACT5B,IAGR,KAAOA,GAAKsD,KAAKoD,OACb9E,GAAS,IACT5B,IAEJ4B,GAAS,KAEb,OAAU0B,KAAKM,UAAS,KAAKhC,GAKjC,sBAAI,qBAAM,C,IAAV,WACI,OAAO0B,KAAKM,UAAU1D,G,gCAG1B,sBAAI,qBAAM,C,IAAV,WACI,OAAOoD,KAAKM,UAAU1D,EAAIoD,KAAKY,KAAKzC,OAAS,G,gCAGjD,sBAAI,oBAAK,C,IAAT,WACI,OAAO6B,KAAKM,UAAU5D,G,gCAG1B,sBAAI,oBAAK,C,IAAT,WACI,OAAOsD,KAAKM,UAAU5D,EAAIsD,KAAKY,KAAK1C,MAAQ,G,gCAGhD,sBAAI,oBAAK,C,IAAT,WACI,OAAO8B,KAAKY,KAAK1C,O,gCAGrB,sBAAI,qBAAM,C,IAAV,WACI,OAAO8B,KAAKY,KAAKzC,Q,gCAGrB,YAAAnB,IAAA,SAAIN,EAAWE,GACX,GAAIA,EAAIoD,KAAK/B,QAAUrB,EAAIoD,KAAKmD,OAC5B,OAAO,EAGX,IADA,IAAMS,EAAO5D,KAAK2D,OAAO/G,EAAIoD,KAAK/B,QACzB1B,EAAI,EAAGA,EAAIqH,EAAKhI,OAAQW,GAAK,EAClC,GAAIG,GAAKkH,EAAKrH,IAAMG,EAAIkH,EAAKrH,EAAI,GAC7B,OAAO,EAGf,OAAO,GAGX,YAAAuH,QAAA,SAAQlH,EAAWqG,GACf,KAAIrG,EAAIoD,KAAK/B,QAAUrB,EAAIoD,KAAKmD,QAIhC,IADA,IAAMS,EAAO5D,KAAK2D,OAAO/G,EAAIoD,KAAK/B,QACzB1B,EAAI,EAAGA,EAAIqH,EAAKhI,OAAQW,GAAK,EAClC0G,EAASW,EAAKrH,GAAIqH,EAAKrH,EAAI,GAAK,IAG5C,EArFA,GAAa,EAAAmH,c,kFCFb,aAOM/D,EAAY,IAAI7C,EAAKC,OAE3B,aAMI,WAAYiB,EAAgBC,EAAiBC,EAAgBC,QACpC,IAAVH,IACPA,EAAQ,QAEU,IAAXC,IACPA,EAAS,QAEQ,IAAVC,IACPA,EAAQ,QAEU,IAAXC,IACPA,EAAS,GAEb6B,KAAKM,UAAY,IAAIxD,EAAKC,OAAOiB,EAAOC,GACxC+B,KAAKY,KAAO,IAAI9D,EAAKgE,KAAK5C,EAAOC,GA0GzC,OArGI,YAAAkC,SAAA,WACI,MAAO,IAAIL,KAAKhC,MAAK,IAAIgC,KAAK/B,OAAM,IAAI+B,KAAK9B,MAAK,IAAI8B,KAAK7B,OAAM,KAGrE,YAAAtC,OAAA,SAAO0F,GACH,OAAOvB,KAAKhC,QAAUuD,EAAMvD,OAASgC,KAAK/B,SAAWsD,EAAMtD,QAAU+B,KAAKY,KAAK/E,OAAO0F,IAG1F,sBAAI,qBAAM,C,IAAV,WACI,OAAOvB,KAAKM,UAAU1D,G,gCAG1B,sBAAI,qBAAM,C,IAAV,WACI,OAAOoD,KAAKM,UAAU1D,EAAIoD,KAAKY,KAAKzC,OAAS,G,gCAGjD,sBAAI,oBAAK,C,IAAT,WACI,OAAO6B,KAAKM,UAAU5D,G,gCAG1B,sBAAI,oBAAK,C,IAAT,WACI,OAAOsD,KAAKM,UAAU5D,EAAIsD,KAAKY,KAAK1C,MAAQ,G,gCAGhD,sBAAI,oBAAK,C,IAAT,WACI,OAAO8B,KAAKY,KAAK1C,O,gCAGrB,sBAAI,qBAAM,C,IAAV,WACI,OAAO8B,KAAKY,KAAKzC,Q,gCAGrB,sBAAI,oBAAK,C,IAAT,WACI,OAAO6B,KAAKY,KAAKmD,O,gCAGrB,sBAAI,mBAAI,C,IAAR,WACI,OAAO/D,KAAKY,KAAKK,M,gCAKrB,YAAAjF,IAAA,SAAIgC,EAAeC,EAAgBC,EAAeC,GAG9C,OAFA6B,KAAKM,UAAUtE,IAAIgC,EAAOC,GAC1B+B,KAAKY,KAAK5E,IAAIkC,EAAOC,GACd6B,MAGX,YAAAC,SAAA,SAASsB,GAGL,OAFAvB,KAAKM,UAAUtE,IAAIuF,EAAMvD,MAAOuD,EAAMtD,QACtC+B,KAAKY,KAAK5E,IAAIuF,EAAMrD,MAAOqD,EAAMpD,QAC1B6B,MAGX,YAAAgE,gBAAA,SAAgBjF,GACZ,IAAMkF,EAAKlF,EAAIrC,EAAIsD,KAAKhC,MACpBiG,EAAK,GACLjE,KAAKY,KAAK1C,OAAS+F,EACnBjE,KAAKM,UAAU5D,EAAIqC,EAAIrC,GAChBuH,GAAMjE,KAAKY,KAAK1C,QACvB8B,KAAKY,KAAK1C,MAAQ+F,EAAK,GAE3B,IAAMC,EAAKnF,EAAInC,EAAIoD,KAAKM,UAAU1D,EAOlC,OANIsH,EAAK,GACLlE,KAAKY,KAAKzC,QAAU+F,EACpBlE,KAAKM,UAAU1D,EAAImC,EAAInC,GAChBsH,GAAMlE,KAAKY,KAAKzC,SACvB6B,KAAKY,KAAKzC,OAAS+F,EAAK,GAErBlE,MAKX,YAAAS,eAAA,SAAe1B,GACX,OAAOiB,KAAKY,KAAKH,eAAed,EAAUM,SAASlB,GAAKwB,eAAeP,KAAKM,aAGhF,YAAA6D,kBAAA,SAAkB5C,GAEd,OADA5B,EAAU3D,IAAIuF,EAAMvD,MAAOuD,EAAMtD,QAAQsC,eAAeP,KAAKM,aACxDN,KAAKY,KAAKH,eAAed,KAGV,IAAhB4B,EAAMrD,OAAgC,IAAjBqD,EAAMpD,SAGxB6B,KAAKY,KAAKH,eAAed,EAAUgC,IAAIJ,EAAMrD,MAAQ,EAAGqD,EAAMpD,OAAS,KAGlF,YAAAiG,kBAAA,SAAkB7C,GACd,OAAOvB,KAAK/B,QAAUsD,EAAMtD,OAASsD,EAAMpD,OAAS,GAC7C6B,KAAKmD,QAAU5B,EAAMtD,QACrB+B,KAAKhC,OAASuD,EAAMvD,MAAQuD,EAAMrD,MAAQ,GAC1C8B,KAAKoD,OAAS7B,EAAMvD,QACnBgC,KAAK+D,OACU,IAAhBxC,EAAMrD,OAAgC,IAAjBqD,EAAMpD,QAGtC,YAAAlB,MAAA,SAAM8B,GACF,OAAOiB,KAAKY,KAAK3D,MAAM0C,EAAUM,SAASlB,GAAKwB,eAAeP,KAAKM,aAE3E,EA9HA,GAAa,EAAAvC,a,2ECFb,iBAMI,WAAYG,EAAgBC,QACH,IAAVD,IACPA,EAAQ,QAEU,IAAXC,IACPA,EAAS,GAEb6B,KAAK9B,MAAQA,EACb8B,KAAK7B,OAASA,EAgEtB,OA3DI,YAAAkC,SAAA,WACI,MAAO,IAAIL,KAAK9B,MAAK,IAAI8B,KAAK7B,OAAM,KAGxC,YAAAtC,OAAA,SAAO0F,GACH,OAAOvB,KAAK9B,QAAUqD,EAAMrD,OAAS8B,KAAK7B,SAAWoD,EAAMpD,QAG/D,sBAAI,oBAAK,C,IAAT,WACI,OAAsB,IAAf6B,KAAK9B,OAA+B,IAAhB8B,KAAK7B,Q,gCAGpC,sBAAI,mBAAI,C,IAAR,WACI,OAAO6B,KAAK9B,MAAQ8B,KAAK7B,Q,gCAK7B,YAAAnC,IAAA,SAAIkC,EAAeC,GAGf,OAFA6B,KAAK9B,MAAQA,EACb8B,KAAK7B,OAASA,EACP6B,MAGX,YAAAC,SAAA,SAASsB,GAGL,OAFAvB,KAAK9B,MAAQqD,EAAMrD,MACnB8B,KAAK7B,OAASoD,EAAMpD,OACb6B,MAGX,YAAA2B,IAAA,SAAIzD,EAAeC,GAGf,OAFA6B,KAAK9B,OAASA,EACd8B,KAAK7B,QAAUA,EACR6B,MAGX,YAAA6B,UAAA,SAAU9C,GAGN,OAFAiB,KAAK9B,OAASa,EAAIrC,EAClBsD,KAAK7B,QAAUY,EAAInC,EACZoD,MAGX,YAAAgC,SAAA,SAASC,GAGL,OAFAjC,KAAK9B,OAAS+D,EACdjC,KAAK7B,QAAU8D,EACRjC,MAOX,YAAAS,eAAA,SAAe1B,GACX,OAAOA,EAAIrC,GAAK,GAAKqC,EAAInC,GAAK,GAAKmC,EAAIrC,EAAIsD,KAAK9B,OAASa,EAAInC,EAAIoD,KAAK7B,QAG1E,YAAAlB,MAAA,SAAM8B,GACF,OAAOA,EAAInC,EAAIoD,KAAK9B,MAAQa,EAAIrC,GAExC,EA9EA,GAAa,EAAAoE,Q,mJCAb,aAAQ,kFAAAuD,oBACR,aAAQ,2EAAA7F,aAAW,gFAAAa,kBAAgB,wEAAAtC,UAAQ,sEAAAwB,QAAM,4EAAAmF,gBCP7CY,EAA2B,GCE/B,ODCA,SAASC,EAAoBC,GAE5B,GAAGF,EAAyBE,GAC3B,OAAOF,EAAyBE,GAAUC,QAG3C,IAAIC,EAASJ,EAAyBE,GAAY,CAGjDC,QAAS,IAOV,OAHAE,EAAoBH,GAAUI,KAAKF,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAGpEG,EAAOD,QCjBRF,CAAoB,M","file":"block-fractal-1.0.4.js","sourcesContent":["import * as geom from './geom';\r\n\r\nexport interface BlockFractalParam {\r\n    random?: () => number;\r\n    iterations: number;\r\n    shape?: geom.Path;\r\n    variation?: number;\r\n}\r\n\r\nfunction nextToLastMatch(points: geom.Offset[], next: geom.Offset) {\r\n    return points.length > 1 && points[points.length - 2].equals(next);\r\n}\r\n\r\nfunction addPoint(points: geom.Offset[], mask: geom.MaskRect, next: geom.Offset) {\r\n    if (nextToLastMatch(points, next)) {\r\n        mask.set(points.splice(points.length - 1, 1)[0], false);\r\n    } else {\r\n        points.push(next);\r\n        mask.set(next, true);\r\n    }\r\n}\r\n\r\nfunction verticalHelper(points: geom.Offset[], random: () => number, variation: number,\r\n                        newPoints: geom.Offset[], mask: geom.MaskRect, i: number,\r\n                        p1: geom.Offset, p2: geom.Offset) {\r\n    const x = 2 * p1.x;\r\n    const yDir = p2.y - p1.y;\r\n    for (let y = 2 * p1.y; y !== 2 * p2.y; y += yDir) {\r\n        const np3 = new geom.Offset(x, y + yDir);\r\n        // console.info(`- ${np3}`);\r\n        if (nextToLastMatch(newPoints, np3)) {\r\n            // This can happen around a corner, when just before the corner\r\n            // we dip into the corner\r\n            // console.info(` remove ${newPoints[newPoints.length - 1]}`);\r\n            mask.set(newPoints.splice(newPoints.length - 1, 1)[0], false);\r\n            continue;\r\n        }\r\n        if (i === points.length - 2 && mask.get(np3)) {\r\n            // This can happen if the first point was on a corner and the\r\n            // first move was to dip into the corner\r\n            const index = newPoints.findIndex((point) => point.equals(np3));\r\n            // console.info(`remove ${index} from beginning`);\r\n            for (const point of newPoints.splice(0, index)) {\r\n                mask.set(point, false);\r\n            }\r\n            addPoint(newPoints, mask, np3);\r\n            break;\r\n        }\r\n        if (random() < variation) {\r\n            const v = Math.floor(random() * 2) * 2 - 1;\r\n            const np1 = new geom.Offset(x + v, y);\r\n            const np2 = new geom.Offset(x + v, y + yDir);\r\n            if (!mask.get(np2)) {\r\n                if (!mask.get(np1) || nextToLastMatch(newPoints, np1)) {\r\n                    addPoint(newPoints, mask, np1);\r\n                    addPoint(newPoints, mask, np2);\r\n                }\r\n            }\r\n        }\r\n        addPoint(newPoints, mask, np3);\r\n    }\r\n}\r\n\r\nfunction horizontalHelper(points: geom.Offset[], random: () => number, variation: number,\r\n                          newPoints: geom.Offset[], mask: geom.MaskRect, i: number,\r\n                          p1: geom.Offset, p2: geom.Offset) {\r\n    const y = 2 * p1.y;\r\n    const xDir = p2.x - p1.x;\r\n    for (let x = 2 * p1.x; x !== 2 * p2.x; x += xDir) {\r\n        const np3 = new geom.Offset(x + xDir, y);\r\n        // console.info(`- ${np3}`);\r\n        if (nextToLastMatch(newPoints, np3)) {\r\n            // This can happen around a corner, when just before the corner\r\n            // we dip in the direction of the corner\r\n            // console.info(` remove ${newPoints[newPoints.length - 1]}`);\r\n            mask.set(newPoints.splice(newPoints.length - 1, 1)[0], false);\r\n            continue;\r\n        }\r\n        if (i === points.length - 2 && mask.get(np3)) {\r\n            // This can happen if the first point was on a corner and the\r\n            // first move was to dip into the corner\r\n            const index = newPoints.findIndex((point) => point.equals(np3));\r\n            // console.info(`remove ${index} from beginning`);\r\n            for (const point of newPoints.splice(0, index)) {\r\n                mask.set(point, false);\r\n            }\r\n            addPoint(newPoints, mask, np3);\r\n            break;\r\n        }\r\n        if (random() < variation) {\r\n            const v = Math.floor(random() * 2) * 2 - 1;\r\n            const np1 = new geom.Offset(x, y + v);\r\n            const np2 = new geom.Offset(x + xDir, y + v);\r\n            if (!mask.get(np2)) {\r\n                if (!mask.get(np1) || nextToLastMatch(newPoints, np1)) {\r\n                    addPoint(newPoints, mask, np1);\r\n                    addPoint(newPoints, mask, np2);\r\n                }\r\n            }\r\n        }\r\n        addPoint(newPoints, mask, np3);\r\n    }\r\n}\r\n\r\nfunction blockFractalIteration(random: () => number, points: geom.Offset[],\r\n                               bounds: geom.RectangleLike, variation: number) {\r\n    const newPoints = new Array<geom.Offset>();\r\n    const newBounds = new geom.Rectangle(\r\n        bounds.westX * 2 - 1,\r\n        bounds.northY * 2 - 1,\r\n        bounds.width * 2 + 2,\r\n        bounds.height * 2 + 2,\r\n    );\r\n    // console.info(` bounds ${newBounds}`);\r\n    const mask = new geom.MaskRect(newBounds);\r\n    for (let i = 0; i < points.length - 1; i ++) {\r\n        const p1 = points[i];\r\n        const p2 = points[i + 1];\r\n        if (i === 0) {\r\n            addPoint(newPoints, mask, new geom.Offset(p1.x * 2, p1.y * 2));\r\n        }\r\n        if (p1.x === p2.x) {\r\n            verticalHelper(points, random, variation, newPoints, mask, i, p1, p2);\r\n        } else {\r\n            horizontalHelper(points, random, variation, newPoints, mask, i, p1, p2);\r\n        }\r\n    }\r\n    return {\r\n        points: newPoints,\r\n        bounds: newBounds,\r\n    };\r\n}\r\n\r\nexport function makeBlockFractal(param: BlockFractalParam): geom.Path {\r\n    let {random, shape, variation} = param;\r\n    if (typeof random === 'undefined') {\r\n        random = Math.random;\r\n    }\r\n    if (typeof shape === 'undefined') {\r\n        shape = new geom.Path({x: -1, y: -1}, [\r\n            geom.Direction.EAST,\r\n            geom.Direction.EAST,\r\n            geom.Direction.SOUTH,\r\n            geom.Direction.SOUTH,\r\n            geom.Direction.WEST,\r\n            geom.Direction.WEST,\r\n            geom.Direction.NORTH,\r\n            geom.Direction.NORTH,\r\n        ]);\r\n    }\r\n    if (typeof variation === 'undefined') {\r\n        variation = 0.4;\r\n    }\r\n\r\n    let points = new Array<geom.Offset>();\r\n    let bounds = shape.getBounds();\r\n    shape.getOffsets((off) => {\r\n        points.push(new geom.Offset(off.x, off.y));\r\n    });\r\n\r\n    for (let iter = 0; iter < param.iterations; iter ++) {\r\n        // console.info(`iteration ${iter + 1}`);\r\n        ({points, bounds} = blockFractalIteration(random, points, bounds, variation));\r\n    }\r\n\r\n    const segments = new Array<geom.Direction>();\r\n    for (let i = 0; i < points.length - 1; i ++) {\r\n        const curPoint = points[i];\r\n        const nextPoint = points[i + 1];\r\n        if (nextPoint.y === curPoint.y - 1) {\r\n            segments.push(geom.Direction.NORTH);\r\n        } else if (nextPoint.x === curPoint.x + 1) {\r\n            segments.push(geom.Direction.EAST);\r\n        } else if (nextPoint.y === curPoint.y + 1) {\r\n            segments.push(geom.Direction.SOUTH);\r\n        } else if (nextPoint.x === curPoint.x - 1) {\r\n            segments.push(geom.Direction.WEST);\r\n        }\r\n    }\r\n\r\n    return new geom.Path(points[0], segments);\r\n}\r\n","import * as geom from '.';\r\n\r\n// tslint:disable:no-bitwise\r\n\r\nexport enum DirectionFlags {\r\n    NONE  = 0,\r\n    NORTH = 1,\r\n    EAST  = 2,\r\n    SOUTH = 4,\r\n    WEST  = 8,\r\n    ALL   = 15,\r\n}\r\n\r\nexport function directionFlagsToString(flags: DirectionFlags) {\r\n    let ret = '[';\r\n    if ((flags & DirectionFlags.NORTH) !== 0) {\r\n        ret += 'N';\r\n    }\r\n    if ((flags & DirectionFlags.EAST) !== 0) {\r\n        ret += 'E';\r\n    }\r\n    if ((flags & DirectionFlags.SOUTH) !== 0) {\r\n        ret += 'S';\r\n    }\r\n    if ((flags & DirectionFlags.WEST) !== 0) {\r\n        ret += 'W';\r\n    }\r\n    return ret + ']';\r\n}\r\n\r\n// conversion\r\n\r\nexport function directionFlagsFromDirection(dir: geom.Direction) {\r\n    return (1 << dir) as DirectionFlags;\r\n}\r\n","// tslint:disable:no-bitwise\r\n\r\nexport enum Direction {\r\n    NORTH = 0,\r\n    EAST  = 1,\r\n    SOUTH = 2,\r\n    WEST  = 3,\r\n}\r\n\r\nexport const DIRECTIONS = [\r\n    Direction.NORTH,\r\n    Direction.EAST,\r\n    Direction.SOUTH,\r\n    Direction.WEST,\r\n];\r\n\r\nconst DIRECTIONS_STR = [\r\n    'N',\r\n    'E',\r\n    'S',\r\n    'W',\r\n];\r\n\r\nexport function directionToString(dir: Direction) {\r\n    return DIRECTIONS_STR[dir];\r\n}\r\n\r\nexport function directionOpposite(dir: Direction) {\r\n    return ((dir + 2) & 3) as Direction;\r\n}\r\n","export * from './direction';\r\nexport * from './direction-flags';\r\nexport * from './offset';\r\nexport * from './size';\r\nexport * from './rectangle';\r\nexport * from './mask';\r\nexport * from './mask-rect';\r\nexport * from './raster-mask';\r\nexport * from './path';\r\n","import * as geom from '.';\r\n\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\nexport class MaskRect implements geom.RectangleLike {\r\n    private readonly _rectangle = new geom.Rectangle();\r\n    private readonly _mask: geom.Mask;\r\n    private readonly _outsideValue: boolean;\r\n\r\n    constructor(rect: geom.RectangleLike, initialValue = false, outsideValue = false) {\r\n        this._rectangle.copyFrom(rect);\r\n        this._mask = new geom.Mask(rect, initialValue);\r\n        this._outsideValue = outsideValue;\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `${this._rectangle.northWest}/${this._outsideValue}\\n${this._mask}`;\r\n    }\r\n\r\n    get westX() {\r\n        return this._rectangle.westX;\r\n    }\r\n\r\n    get northY() {\r\n        return this._rectangle.northY;\r\n    }\r\n\r\n    get width() {\r\n        return this._rectangle.width;\r\n    }\r\n\r\n    get height() {\r\n        return this._rectangle.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this._mask.index(LOCAL_OFF.copyFrom(off).subtractOffset(this._rectangle.northWest));\r\n    }\r\n\r\n    getAt(index: number) {\r\n        return this._mask.getAt(index);\r\n    }\r\n\r\n    get(off: geom.OffsetLike) {\r\n        if (!this._rectangle.containsOffset(off)) {\r\n            return this._outsideValue;\r\n        }\r\n        return this._mask.getAt(this._rectangle.index(off));\r\n    }\r\n\r\n    // mutators\r\n\r\n    setAt(index: number, value: boolean) {\r\n        this._mask.setAt(index, value);\r\n        return this;\r\n    }\r\n\r\n    set(off: geom.OffsetLike, value: boolean) {\r\n        this._mask.setAt(this._rectangle.index(off), value);\r\n        return this;\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nexport class Mask implements geom.SizeLike {\r\n    private readonly _size = new geom.Size();\r\n    private readonly _bits: number[];\r\n    // TODO consider Uint8Array for bits\r\n\r\n    constructor(size: geom.SizeLike, initialValue = false) {\r\n        this._size.copyFrom(size);\r\n        this._bits = new Array<number>(Math.ceil(this._size.area / 32)).fill(initialValue ? 0xffffffff : 0);\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        let ret = '';\r\n        const off = new geom.Offset();\r\n        for (let y = 0; y < this._size.height; y ++) {\r\n            for (let x = 0; x < this._size.width; x ++) {\r\n                off.set(x, y);\r\n                ret += this.get(off.set(x, y)) ? '☑' : '☐';\r\n            }\r\n            ret += '\\n';\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    get width() {\r\n        return this._size.width;\r\n    }\r\n\r\n    get height() {\r\n        return this._size.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this._size.index(off);\r\n    }\r\n\r\n    getAt(index: number) {\r\n        // tslint:disable:no-bitwise\r\n        const arrayIndex = index >>> 5;\r\n        const bitMask = 1 << (index & 31);\r\n        return (this._bits[arrayIndex] & bitMask) !== 0;\r\n        // tslint:enable:no-bitwise\r\n    }\r\n\r\n    get(off: geom.OffsetLike) {\r\n        return this.getAt(this.index(off));\r\n    }\r\n\r\n    // mutators\r\n\r\n    setAt(index: number, value: boolean) {\r\n        // tslint:disable:no-bitwise\r\n        const arrayIndex = index >>> 5;\r\n        const bitMask = 1 << (index & 31);\r\n        if (value) {\r\n            this._bits[arrayIndex] |= bitMask;\r\n        } else {\r\n            this._bits[arrayIndex] &= ~bitMask;\r\n        }\r\n        // tslint:enable:no-bitwise\r\n        return this;\r\n    }\r\n\r\n    set(off: geom.OffsetLike, value: boolean) {\r\n        return this.setAt(this.index(off), value);\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nconst X_FROM_DIRECTION = [  0, 1, 0, -1 ];\r\nconst Y_FROM_DIRECTION = [ -1, 0, 1,  0 ];\r\n\r\nexport interface OffsetLike {\r\n    readonly x: number;\r\n    readonly y: number;\r\n}\r\n\r\nexport class Offset implements OffsetLike {\r\n    x: number;\r\n    y: number;\r\n\r\n    constructor();\r\n    constructor(x: number, y: number);\r\n    constructor(x?: number, y?: number) {\r\n        if (typeof x === 'undefined') {\r\n            x = 0;\r\n        }\r\n        if (typeof y === 'undefined') {\r\n            y = 0;\r\n        }\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `(${this.x},${this.y})`;\r\n    }\r\n\r\n    equals(other: OffsetLike) {\r\n        return this.x === other.x && this.y === other.y;\r\n    }\r\n\r\n    // chebyshev: can move in any direction (diagonals are ok)\r\n    get magnitudeChebyshev() {\r\n        return Math.max(Math.abs(this.x), Math.abs(this.y));\r\n    }\r\n\r\n    // manhattan: can move only in cardinal directions (no diagonals)\r\n    get magnitudeManhattan(): number {\r\n        return Math.abs(this.x) + Math.abs(this.y);\r\n    }\r\n\r\n    // mutators\r\n\r\n    set(x: number, y: number) {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n\r\n    copyFrom(other: OffsetLike) {\r\n        this.x = other.x;\r\n        this.y = other.y;\r\n        return this;\r\n    }\r\n\r\n    setFromDirection(dir: geom.Direction) {\r\n        this.x = X_FROM_DIRECTION[dir];\r\n        this.y = Y_FROM_DIRECTION[dir];\r\n        return this;\r\n    }\r\n\r\n    add(x: number, y: number) {\r\n        this.x += x;\r\n        this.y += y;\r\n        return this;\r\n    }\r\n\r\n    addSize(size: geom.SizeLike) {\r\n        this.x += size.width;\r\n        this.y += size.height;\r\n        return this;\r\n    }\r\n\r\n    addOffset(off: OffsetLike) {\r\n        this.x += off.x;\r\n        this.y += off.y;\r\n        return this;\r\n    }\r\n\r\n    addDirection(dir: geom.Direction) {\r\n        this.x += X_FROM_DIRECTION[dir];\r\n        this.y += Y_FROM_DIRECTION[dir];\r\n        return this;\r\n    }\r\n\r\n    addCardinalDirection(dir: geom.Direction) {\r\n        this.x += X_FROM_DIRECTION[dir];\r\n        this.y += Y_FROM_DIRECTION[dir];\r\n        return this;\r\n    }\r\n\r\n    subtractOffset(off: OffsetLike) {\r\n        this.x -= off.x;\r\n        this.y -= off.y;\r\n        return this;\r\n    }\r\n\r\n    multiply(factor: number) {\r\n        this.x *= factor;\r\n        this.y *= factor;\r\n        return this;\r\n    }\r\n\r\n    // utilities\r\n\r\n    // chebyshev: can move in any direction (diagonals are ok)\r\n    distanceChebyshev(other: OffsetLike) {\r\n        return this.subtractOffset(other).magnitudeChebyshev;\r\n    }\r\n\r\n    // manhattan: can move only in cardinal directions (no diagonals)\r\n    distanceManhattan(other?: OffsetLike): number {\r\n        return this.subtractOffset(other).magnitudeManhattan;\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\nfunction sortedInsert(array: number[], value: number) {\r\n    let low = 0;\r\n    let high = array.length;\r\n\r\n    while (low < high) {\r\n        // tslint:disable-next-line:no-bitwise\r\n        const mid = (low + high) >>> 1;\r\n        if (array[mid] < value) {\r\n            low = mid + 1;\r\n        } else {\r\n            high = mid;\r\n        }\r\n    }\r\n\r\n    array.splice(low, 0, value);\r\n}\r\n\r\nexport class Path {\r\n    start: geom.Offset;\r\n    segments: geom.Direction[];\r\n\r\n    constructor();\r\n    constructor(start: geom.OffsetLike, segments: geom.Direction[]);\r\n    constructor(start?: geom.OffsetLike, segments?: geom.Direction[]) {\r\n        this.start = new geom.Offset();\r\n        if (typeof start !== 'undefined') {\r\n            this.start.copyFrom(start);\r\n        }\r\n        if (typeof segments === 'undefined') {\r\n            segments = new Array<geom.Direction>();\r\n        }\r\n        this.segments = segments;\r\n    }\r\n\r\n    toString() {\r\n        return `${this.start.toString()}:`\r\n            + `${this.segments.map((segment) => geom.directionToString(segment)).join('')}`;\r\n    }\r\n\r\n    getIsClosed() {\r\n        LOCAL_OFF.copyFrom(this.start);\r\n        for (const segment of this.segments) {\r\n            LOCAL_OFF.addDirection(segment);\r\n        }\r\n        return this.start.equals(LOCAL_OFF);\r\n    }\r\n\r\n    getOffsets(callback: (off: geom.OffsetLike) => void) {\r\n        const cursor = new geom.Offset();\r\n        cursor.copyFrom(this.start);\r\n        callback(cursor);\r\n        for (const segment of this.segments) {\r\n            cursor.addDirection(segment);\r\n            callback(cursor);\r\n        }\r\n    }\r\n\r\n    getBounds(): geom.Rectangle {\r\n        let northY = this.start.y;\r\n        let southY = northY;\r\n        let westX = this.start.x;\r\n        let eastX = westX;\r\n        LOCAL_OFF.copyFrom(this.start);\r\n        for (const segment of this.segments) {\r\n            LOCAL_OFF.addDirection(segment);\r\n            switch (segment) {\r\n            case geom.Direction.NORTH:\r\n                northY = Math.min(northY, LOCAL_OFF.y);\r\n                break;\r\n            case geom.Direction.EAST:\r\n                eastX = Math.max(eastX, LOCAL_OFF.x);\r\n                break;\r\n            case geom.Direction.SOUTH:\r\n                southY = Math.max(southY, LOCAL_OFF.y);\r\n                break;\r\n            case geom.Direction.WEST:\r\n                westX = Math.min(westX, LOCAL_OFF.x);\r\n                break;\r\n            }\r\n        }\r\n        return new geom.Rectangle(westX, northY, eastX - westX + 1, southY - northY + 1);\r\n    }\r\n\r\n    getArea() {\r\n        let total = 0;\r\n        LOCAL_OFF.copyFrom(this.start);\r\n        for (const segment of this.segments) {\r\n            LOCAL_OFF.addDirection(segment);\r\n            switch (segment) {\r\n            case geom.Direction.NORTH:\r\n                total -= LOCAL_OFF.x;\r\n                break;\r\n            case geom.Direction.SOUTH:\r\n                total += LOCAL_OFF.x;\r\n                break;\r\n            }\r\n        }\r\n        return Math.abs(total);\r\n    }\r\n\r\n    rasterize(bounds?: geom.RectangleLike): geom.RasterMask {\r\n        const lines = new Array<number[]>();\r\n        if (typeof bounds === 'undefined') {\r\n            bounds = this.getBounds();\r\n        }\r\n        LOCAL_OFF.copyFrom(this.start);\r\n        const {northY} = bounds;\r\n        const southY = northY + bounds.height - 1;\r\n        for (let y = northY; y < southY; y ++) {\r\n            lines.push([]);\r\n        }\r\n        LOCAL_OFF.copyFrom(this.start);\r\n        for (const segment of this.segments) {\r\n            if (segment === geom.Direction.SOUTH) {\r\n                sortedInsert(lines[LOCAL_OFF.y - northY], LOCAL_OFF.x);\r\n            }\r\n            LOCAL_OFF.addDirection(segment);\r\n            if (segment === geom.Direction.NORTH) {\r\n                sortedInsert(lines[LOCAL_OFF.y - northY], LOCAL_OFF.x);\r\n            }\r\n        }\r\n        return new geom.RasterMask({\r\n            westX: bounds.westX,\r\n            northY: bounds.northY,\r\n            width: bounds.width - 1,\r\n            height: bounds.height - 1,\r\n        }, lines);\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nexport class RasterMask implements geom.RectangleLike, geom.SizeLike {\r\n    northWest: geom.Offset;\r\n    size: geom.Size;\r\n    private _lines: number[][];\r\n\r\n    constructor(bounds: geom.RectangleLike, lines: number[][]) {\r\n        this.northWest = new geom.Offset(bounds.westX, bounds.northY);\r\n        this.size = new geom.Size(bounds.width, bounds.height);\r\n        this._lines = lines;\r\n    }\r\n\r\n    toString() {\r\n        let shape = '';\r\n        for (let y = 0; y < this.height; y ++) {\r\n            const line = this._lines[y];\r\n            let x = this.westX;\r\n            for (let i = 0; i < line.length; i += 2) {\r\n                const start = line[i];\r\n                const end = line[i + 1];\r\n                while (x < start) {\r\n                    shape += '∙';\r\n                    x ++;\r\n                }\r\n                while (x < end) {\r\n                    shape += '█';\r\n                    x ++;\r\n                }\r\n            }\r\n            while (x <= this.eastX) {\r\n                shape += '∙';\r\n                x ++;\r\n            }\r\n            shape += '\\n';\r\n        }\r\n        return `${this.northWest}\\n${shape}`;\r\n    }\r\n\r\n    // accessors\r\n\r\n    get northY() {\r\n        return this.northWest.y;\r\n    }\r\n\r\n    get southY() {\r\n        return this.northWest.y + this.size.height - 1;\r\n    }\r\n\r\n    get westX() {\r\n        return this.northWest.x;\r\n    }\r\n\r\n    get eastX() {\r\n        return this.northWest.x + this.size.width - 1;\r\n    }\r\n\r\n    get width() {\r\n        return this.size.width;\r\n    }\r\n\r\n    get height() {\r\n        return this.size.height;\r\n    }\r\n\r\n    get(x: number, y: number) {\r\n        if (y < this.northY || y > this.southY) {\r\n            return false;\r\n        }\r\n        const line = this._lines[y - this.northY];\r\n        for (let i = 0; i < line.length; i += 2) {\r\n            if (x >= line[i] && x < line[i + 1]) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    bandsAt(y: number, callback: (westX: number, eastX: number) => void) {\r\n        if (y < this.northY || y > this.southY) {\r\n            return;\r\n        }\r\n        const line = this._lines[y - this.northY];\r\n        for (let i = 0; i < line.length; i += 2) {\r\n            callback(line[i], line[i + 1] - 1);\r\n        }\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nexport interface RectangleLike extends geom.SizeLike {\r\n    readonly westX: number;\r\n    readonly northY: number;\r\n}\r\n\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\nexport class Rectangle implements RectangleLike, geom.SizeLike {\r\n    northWest: geom.Offset;\r\n    size: geom.Size;\r\n\r\n    constructor();\r\n    constructor(westX: number, northY: number, width: number, height: number);\r\n    constructor(westX?: number, northY?: number, width?: number, height?: number) {\r\n        if (typeof westX === 'undefined') {\r\n            westX = 0;\r\n        }\r\n        if (typeof northY === 'undefined') {\r\n            northY = 0;\r\n        }\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        this.northWest = new geom.Offset(westX, northY);\r\n        this.size = new geom.Size(width, height);\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `(${this.westX},${this.northY} ${this.width}x${this.height})`;\r\n    }\r\n\r\n    equals(other: RectangleLike) {\r\n        return this.westX === other.westX && this.northY === other.northY && this.size.equals(other);\r\n    }\r\n\r\n    get northY() {\r\n        return this.northWest.y;\r\n    }\r\n\r\n    get southY() {\r\n        return this.northWest.y + this.size.height - 1;\r\n    }\r\n\r\n    get westX() {\r\n        return this.northWest.x;\r\n    }\r\n\r\n    get eastX() {\r\n        return this.northWest.x + this.size.width - 1;\r\n    }\r\n\r\n    get width() {\r\n        return this.size.width;\r\n    }\r\n\r\n    get height() {\r\n        return this.size.height;\r\n    }\r\n\r\n    get empty() {\r\n        return this.size.empty;\r\n    }\r\n\r\n    get area() {\r\n        return this.size.area;\r\n    }\r\n\r\n    // mutators\r\n\r\n    set(westX: number, northY: number, width: number, height: number) {\r\n        this.northWest.set(westX, northY);\r\n        this.size.set(width, height);\r\n        return this;\r\n    }\r\n\r\n    copyFrom(other: RectangleLike) {\r\n        this.northWest.set(other.westX, other.northY);\r\n        this.size.set(other.width, other.height);\r\n        return this;\r\n    }\r\n\r\n    extendToInclude(off: geom.OffsetLike) {\r\n        const dx = off.x - this.westX;\r\n        if (dx < 0) {\r\n            this.size.width -= dx;\r\n            this.northWest.x = off.x;\r\n        } else if (dx >= this.size.width) {\r\n            this.size.width = dx + 1;\r\n        }\r\n        const dy = off.y - this.northWest.y;\r\n        if (dy < 0) {\r\n            this.size.height -= dy;\r\n            this.northWest.y = off.y;\r\n        } else if (dy >= this.size.height) {\r\n            this.size.height = dy + 1;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // utilities\r\n\r\n    containsOffset(off: geom.OffsetLike) {\r\n        return this.size.containsOffset(LOCAL_OFF.copyFrom(off).subtractOffset(this.northWest));\r\n    }\r\n\r\n    containsRectangle(other: RectangleLike) {\r\n        LOCAL_OFF.set(other.westX, other.northY).subtractOffset(this.northWest);\r\n        if (!this.size.containsOffset(LOCAL_OFF)) {\r\n            return false;\r\n        }\r\n        if (other.width === 0 && other.height === 0) {\r\n            return false;\r\n        }\r\n        return this.size.containsOffset(LOCAL_OFF.add(other.width - 1, other.height - 1));\r\n    }\r\n\r\n    overlapsRectangle(other: RectangleLike) {\r\n        return this.northY <= other.northY + other.height - 1\r\n            && this.southY >= other.northY\r\n            && this.westX <= other.westX + other.width - 1\r\n            && this.eastX >= other.westX\r\n            && !this.empty\r\n            && other.width !== 0 && other.height !== 0;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this.size.index(LOCAL_OFF.copyFrom(off).subtractOffset(this.northWest));\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nexport interface SizeLike {\r\n    readonly width: number;\r\n    readonly height: number;\r\n}\r\n\r\nexport class Size implements SizeLike {\r\n    width: number;\r\n    height: number;\r\n\r\n    constructor();\r\n    constructor(width: number, height: number);\r\n    constructor(width?: number, height?: number) {\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `(${this.width}x${this.height})`;\r\n    }\r\n\r\n    equals(other: SizeLike) {\r\n        return this.width === other.width && this.height === other.height;\r\n    }\r\n\r\n    get empty() {\r\n        return this.width === 0 || this.height === 0;\r\n    }\r\n\r\n    get area() {\r\n        return this.width * this.height;\r\n    }\r\n\r\n    // mutators\r\n\r\n    set(width: number, height: number) {\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n\r\n    copyFrom(other: SizeLike) {\r\n        this.width = other.width;\r\n        this.height = other.height;\r\n        return this;\r\n    }\r\n\r\n    add(width: number, height: number) {\r\n        this.width += width;\r\n        this.height += height;\r\n        return this;\r\n    }\r\n\r\n    addOffset(off: geom.OffsetLike) {\r\n        this.width += off.x;\r\n        this.height += off.y;\r\n        return this;\r\n    }\r\n\r\n    multiply(factor: number) {\r\n        this.width *= factor;\r\n        this.height *= factor;\r\n        return this;\r\n    }\r\n\r\n    // TODO: rotate\r\n\r\n    // utilities\r\n\r\n    containsOffset(off: geom.OffsetLike) {\r\n        return off.x >= 0 && off.y >= 0 && off.x < this.width && off.y < this.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return off.y * this.width + off.x;\r\n    }\r\n}\r\n","/*\r\n *  BlockFractal\r\n *  github.com/sbj42/block-fractal\r\n *  James Clark\r\n *  Licensed under the MIT license.\r\n */\r\n\r\nexport {makeBlockFractal} from './block-fractal';\r\nexport {Direction, DirectionFlags, Offset, Path, RasterMask} from './geom';\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(607);\n"],"sourceRoot":""}